

# 一、js

## 1.1、this的指向&箭头函数

**this不是定义的时候决定的，它是函数的当前执行环境决定的，或者说是this指向的是最终调用它的对象（当调用它的对象包含多个对象时，尽管函数是被最外层的对象调用的，this指向的是函数的上一级对象）。**

Exp:

```javascript
var message = "outside"
function f1(){
  var message = "inside";
  console.log(this.message);//outside
  console.log(this);//Window
}
```

由于f1是在全局对象Window中执行的，所以此时的this指向的是Window对象。

Exp：

```javascript
var message = "outside";
var obj = {
  messgae : "inside";
  f1:function(){
    console.log(this.message);
  }
} 
obj.f1();//inside
```

这里函数f1是在obj中执行的，所以此时的this指向的是对象obj。上面的window对象是js中的全局对象，我们创建的变量实际上就是给window对象添加属性。

**当调用它的对象包含多个对象时，尽管函数是被最外层的对象调用的，this指向的是函数的上一级对象**

这句话是是什么意思呢？

exp:

```javascript
var o = {
  message:"outside",
		a:{
      message:"middle",
      b:{
        message:"inside",
        fn:function(){
          console.log(this.message);
        }
      }
    }
}
o.a.b.fn();//inside
```

此时调用函数fn的对象是o，但是，输出的却是对象b中的属性值，这就是因为this会指向它的上一级对象。

再来一个例子验证一下结论

exp:

```javascript
var o = {
  message:"outside",
		a:{
      message:"middle",
      b:{
        message:"inside",
        fn:function(){
          console.log(this.message);
        }
      }
    }
}
var f = o.a.b.fn;
f();//undefined
```

此时的fn()相当于window.fn()，this指向的是window对象。

参考：https://www.cnblogs.com/pssp/p/5216085.html

箭头函数中的this是在定义的时候决定的，箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this，且无论怎么改变调用方式都不会改变this的指向。

exp:

```javascript
var message = "outside";
var obj = {
  message:"inside",
  fn:()=>{
    console.log(this.message);
  }
}
obj.fn();//outside
```

此时的箭头函数的作用域链的上一层就是window对象，所以此时的this指向的是全局对象window。

exp:

```javascript
var message = "window";
var obj = {
  message : "obj";
  fn: function(){
    return ()=>{
      console.log(this.message);
    }
  }
}
obj.fn()();//obj
```

```javascript
var message = "window";
var obj = {
  message : "obj",
  fn: function(){
    return function(){
      console.log(this.message);
    }
  }
}
obj.fn()();//window
```

这里return箭头函数的时候返回的是当前对象obj，此时的fn是一个闭包，函数fn内是一个完整的作用域，此时的作用域链的上一层就是obj，所以this指向obj。

当return的是匿名函数时，因为匿名函数是在全局作用域中执行的，所以此时的this指向的是window。

这里我们总结出来一个结论：

**当有外部函数包裹箭头函数时，this指向的是当前的对象；**

**当没有外部函数包裹箭头函数时，this指向的是window；**

## 1.2、promise和setTimeout的执行顺序

```javascript
var p = Promise.resolve(1);
console.log(2);
setTimeout(()=>{
	console.log(3);
},0)
p.then((res)=>{
	console.log(res);
})
console.log(4);//打印结果：2 4 1 3
```

promise会在当前事件循环的末尾执行，setTimeout是在下一次事件循环中执行。

## 1.3、事件循环 宏任务/微任务

### 1.3.1浏览器中的事件循环

浏览器在执行任务时，同步任务会进入主线程，即执行栈，异步任务会进入事件队列Event Queue。主线程内的任务执行完毕，会去事件队列中调取异步任务推入主线程执行，这个过程不断重复就是事件循环（Event Loop）。

<img src="/Users/zhangtengfei9/Library/Application Support/typora-user-images/image-20191111143452056.png" alt="image-20191111143452056" style="zoom:50%;" />

在事件循环中，一个 完整的循环称为tick，关键步骤：

1、在当前tick中选择宏任务执行，这里的宏任务一般是script（整体代码）；

2、检查任务队列中是否有微任务，如果存在则执行，直至执行完所有的微任务；

3、更新render；

4、重复以上步骤。

<img src="/Users/zhangtengfei9/Library/Application Support/typora-user-images/image-20191111143531796.png" alt="image-20191111143531796" style="zoom:67%;" />

宏任务：script整体代码、setTimeout、setInterval、I/O、UI交互事件、setImmediate（Node.js执行环境）

微任务：Promise、process.nextTick（node.js执行环境）	

Exp

```javascript
console.log("script start");
setTimeout(function(){
  console.log("setTimeout");
},0);
Promise.resolve().then(function(){
  console.log("promise then1");
}).then(function(){
  console.log("promise then2");
});
console.log("end");
//script start 
//end
//promise then1
//promise then2
//setTimeout
```

比较复杂的Exp

```javascript
async function async1(){
  console.log("async1 start");
  await async2();//此时，执行完async2之后，后面的语句暂停执行，跳出括号执行外面的同步任务。外部同步代码执行完毕，接着回到async1()内部, 由于async2()其实是返回一个Promise, await async2()相当于获取它的值，其实就相当于这段代码Promise.resolve(undefined).then((undefined) => {}),所以.then会被推入微任务队列, 所以现在微任务队列会有两个任务。接下来处理微任务队列，打印console.log( 'promise2' )，后面一个.then不会有任何打印，但是会执行
  console.log("async1 end");
}
async function async2(){
  console.log("async2")
}
console.log("script start")
setTimeout(function(){
  console.log("setTimeout")
},0)
async1();
new Promise(function(resolve){
  console.log("promise1")
	resolve();
}).then(function(){//第一次循环时，此时将这句加入到任务队列。
  console.log("promise2")
})
console.log("script end")
//script start
//async1 start
//async 2
//promise1
//script end
//async1 end
//promise2 
//setTimeout
```

### 1.3.2 node中的事件循环

node中的事件循环和浏览器中的是完全不同的东西。node采用V8作为js引擎，而I/O处理方面自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了基于事件驱动的跨平台抽象层。

node的运行机制如下：

1、V8引擎解析js脚本

2、解析后的代码调用node api

3、libuv库负责node api的执行。他将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的执行结果返回给V8引擎

4、V8引擎再将结果返回给用户

外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段（按照该顺序反复运行）...

- timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调
- I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调
- idle, prepare 阶段：仅node内部使用
- poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里
- check 阶段：执行 setImmediate() 的回调
- close callbacks 阶段：执行 socket 的 close 事件回调
  链接：https://juejin.im/post/5c337ae06fb9a049bc4cd218

#### setTimeout 和 setImmediate

二者非常相似，区别主要在于调用时机不同。

- setImmediate 设计在poll阶段完成时执行，即check阶段；`setImmediate()` 设计为一旦在当前 **轮询** 阶段完成， 就执行脚本。
- setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行。`setTimeout()` 在最小阈值（ms 单位）过后运行脚本。

执行计时器的顺序将根据调用它们的上下文而异。如果二者都从主模块内调用，则计时器将受进程性能的约束（这可能会受到计算机上其他正在运行应用程序的影响）。但是，如果你把这两个函数放入一个 I/O 循环内调用，setImmediate 总是被优先调用。使用 `setImmediate()` 相对于`setTimeout()` 的主要优势是，如果`setImmediate()`是在 I/O 周期内被调度的，那它将会在其中任何的定时器之前执行，跟这里存在多少个定时器无关

https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/

####  process.nextTick

这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。

**浏览器与node的事件循环差异：**

差异体现在nodeV10之前 浏览器是执行完一个宏任务就会去清空微任务队列；node则是将同源的宏任务队列执行完毕后再去清空微任务队列

## 1.4、强缓存和协商缓存

**浏览器缓存分为强缓存和协商缓存，强缓存就是不经过浏览器而强制浏览器使用本地的缓存数据，与强缓存相关的两个字段是expires和cache-control；协商缓存就是由服务器确定缓存资源是否可用，客户端后和服务器要通过某种标识来进行通信，从而让服务器判断是否可以缓存访问。**

![image-20191112172604980](/Users/zhangtengfei9/Library/Application Support/typora-user-images/image-20191112172604980.png)

##### 强缓存

**Expires**:这是http1.0的规范，它的值是一个GMT格式的时间字符串，也就是过期的截止时间，如果请求的时间在这之前，那么本地的缓存是有效的，否则就是发送请求到服务器获取资源。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现`Cache-Control:max-age`和`Expires`，那么`max-age`优先级更高。

**Cache-control:max-age=number**，这是http1.1时定义的字段属性，单位是秒。它是一个相对时间，资源第一次请求的时间和cache-control设定的时间计算出一个资源过期时间，再拿这个时间和当前的请求的时间做对比，如果在请求的时间在这个是假之前就是命中缓存。

+ no-cache：不使用本地缓存。
+ no-store：不强制缓存也不协商缓存。
+ public：浏览器和代理服务器都可以缓存（对于private和public，前端可以认为一样，不用深究）。
+ private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。

##### 协商缓存

这个主要涉及到两组header字段：`Etag`和`If-None-Match`、`Last-Modified`和`If-Modified-Since`。

Etag/If-None-Match是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。Etag保证每一个资源是唯一的，资源的变化会导致Etag的变化。是在第一次请求返回时的资源最后修改时间，当第二次再次请求资源时，Etag以If-None-Match的形式传给服务器，服务器根据If-None-Match的值是否改变来判断是否命中缓存。与last-Modified不同的是，当服务器返回304时，由于Etag是重新生成的，此时response会返回Etag，即使Etag和之前的没有变化。

Last-Modified/If-Modified-Since是在第一次请求返回时的资源最后修改时间，当第二次再次请求资源时，last-Modified以If-Modified-Since的形式传给服务器，服务器根据最后修改时间判断是否命中缓存。如果资源没有变化则返回304，此时不会返回资源内容，也不会返回last-Modified。如果有变化返回200,返回资源。

|              | **获取资源形式** | **状态码**          | **发送请求到服务器**                       |
| ------------ | ---------------- | ------------------- | ------------------------------------------ |
| **强缓存**   | 从缓存取         | 200（from cache）   | 否，直接从缓存取                           |
| **协商缓存** | 从缓存取         | 304（not modified） | 是，正如其名，通过服务器来告知缓存是否可用 |

#####为什么要Etag

上面的描述中通过last-modified就可以判断是否使用缓存的资源，为什么还需要Etag呢？这里的Etag是http1.1中对上个版本做的优化，原因如下：

+ 一些资源可能会更改，但是其内容可能没有什么变化，此时如果仅仅使用last-modified判断的话就会重新get服务器资源请求，而通过Etag判断的话就不会重新请求资源。

+ If-modified-Since是秒为单位的，如果某个资源在一秒内修改了多次，此时根据这个字段是没有办法判断更新的。

+ 某些服务器不能精确的得到文件的最后修改时间。

  If-None-Match和If-modified-Since是可以同时使用的，服务器收到这两个字段时**ETag优先级更高**，当Etag（`If-None-Match`）一致时，继续比对`Last-Modified`（`If-Modified-Since`），最后才决定是否返回304。

强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存，主要过程如下：

## 1.5、闭包

##### 什么是闭包？

闭包就是有权访问另一个函数作用域中变量的函数，也就是说闭包可以让你从内部函数访问外部函数的作用域。

**闭包的作用**
**1、封装私有变量**

**2、实现模块化**

**3、模拟块级作用域**

```javascript
function outer(){
  var a = "999";
  var inner = function(){
    console.log(a);
  }
  return inner;
}
var result = outer();
result();
```

此时的inner函数就是一个闭包。

正常情况下outer函数执行完之后，其作用域会被销毁，垃圾回收器会释放那段内存空间。

总结：某个函数在定义函数的作用域之外的地方被调用，闭包可以使该函数访问定义时的词法作用域。

Exp:

```javascript
for(var i = 0;i<10;i++){
  setTimeout(function(){
    console.log(i);
  },1000)
}
```

上面的例子会输出10个10，而不是1，2，3，4......10；setTimeout里的匿名函数执行的时候i已经是10了，所以会输出10次10。怎么解决这个问题呢？就是在for循环每次在执行的时候保存当时的i的值，这就需要一个私有作用域，在这个私有的作用域中保存当时的i的值。

```javascript
方法1：立即执行函数
for(var i = 0;i<10;i++){
  (function(){
	  var j = i;
    setTimeout(function(){
      console.log(j);
    },1000)
  })()
}
方法2：返回一个匿名函数赋值
for (var i = 0; i < 3; i++) {
  data[i] = (function (num) {
      return function(){
          console.log(num);
      }
  })(i);
}
方法3：使用ES6中的let

```

**面试题**：exp

```javascript
function fn(n,o){
  console.log(o);
  return {
    fn:function(m){
      return fn (m,n);
    }
  };
}
var a = fn(0);a.fn(1);a.fn(2);a.fn(3);//undefined 0 0 0
var b = fn(0).fn(1).fn(2).fn(3);//undefined 0 1 2
var c = fn(0).fn(1);c.fn(2);c.fn(3);//undefided 0 1 1
```

1、a

fn(0)执行时，输出o时undefined，返回值是{function fn(m){return fn(m,0)}}对象，此时的第二层fn函数就是一个闭包，n = 0被保存到闭包中;

a.fn(1)当该函数return时，执行fn(1,0)，输出0；

a.fn(2)当该函数return时，执行fn(2,0)，输出0；

a.fn(2)当该函数return时，执行fn(3,0)，输出0；

2、b

fn(0)执行时，输出o时undefined，返回值是{function fn(m){return fn(m,0)}}，此时的第二层fn函数就是一个闭包，n = 0被保存到闭包中;

fn(0).fn(1)执行时，return语句会执行fn(1,0)，输出0，此时n=1被保存在闭包函数中，此时返回{function fn(m){return fn(m,1)}}对象；

fn(0).fn(1).fn(2)执行时，就是执行fn(2,1)，输出1，此时n=2被保存在闭包函数中，此时返回{function fn(m){return fn(m,2)}}对象；

fn(0).fn(1).fn(2).fn(3)执行时，就是执行fn(3,2)，输出2，此时n=3被保存在闭包函数中，此时返回{function fn(m){return fn(m,3)}}对象；

3、c

c就是对象{function fn(m){return fn(m,1}}，此时n=1被保存在闭包函数中，此时依次输出undefined，0；

c.fn(2)执行时，就是fn(2,1)执行，输出1，此时n=2保存在闭包中，返回值是{function fn(m){return fn(m,2)}}对象；

c.fn(3)执行时，就是执行fn(3,1)，输出1，此时n=3被保存在闭包中，返回值是{function fn(m){return fn(m,3)}}对象；

[参考：](https://www.cnblogs.com/xxcanghai/p/4991870.html)

**闭包并不是内存泄漏的根本原因**，根本原因是在ie9之前的的版本，dom和bom中的对象是以com对象实现的，而com对象的垃圾回收机制采用的是引用计数，虽然ie的javascrip采用的是标记清除策略，但是访问com对象仍然是基于引用计数的。闭包并不会引起内存泄漏，只是由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集，从而导致内存无法进行回收，这是IE的问题，所以闭包和内存泄漏没半毛钱关系。

## 1.6、打开浏览器有多少进程

## 1.7、浏览器的缓存方法有哪些？优先级是怎样的？

浏览器的缓存方式主要有**Cookie、LocalStorage、SessionStorage、Serviece Worker**

Cookie：一般指网站为了辨别用户身份存储在终端上的数据，它一般是通过http请求中在头部一起发送到服务器。一般大小是4k。

LocalStorage：是html5的一种新的本地缓存方式，一般用来存储ajax返回的数据，加快页面下一次的打开速度。

它会一直保存在内存中，直到用户清除浏览器为止，容量大小一般是5M。

SessionStorage：特性同LocalStorage，页面关闭时，sessionStorage回清空。

|      特性      |                            Cookie                            |                        localStorage                         |                   sessionStorage                   |      |
| :------------: | :----------------------------------------------------------: | :---------------------------------------------------------: | :------------------------------------------------: | ---- |
|  数据的生命期  | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 |                  除非被清除，否则永久保存                   |    仅在当前会话下有效，关闭页面或浏览器后被清除    |      |
|  存放数据大小  |                            4K左右                            |                          一般为5MB                          |                     一般为5MB                      |      |
| 与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 |     仅在客户端（即浏览器）中保存，不参与和服务器的通信      | 仅在客户端（即浏览器）中保存，不参与和服务器的通信 |      |
|     易用性     |          需要程序员自己封装，源生的Cookie接口不友好          | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 |                                                    |      |

##  1.8、状态值304？为什么要减少https的请求？

##### 304

当浏览器GET请求的时候，如果有If-Modified-Since，则会与当前服务器上相关资源最后一次修改时间进行对比，如果相同则返回304（资源可访问，但没修改），否则加载最新数据，浏览器再缓存起来。这样减少网络数据传输和服务器压力。

为什么要减少https请求？

因为每次请求request都会带数据，请求头里这些数据的传输是需要时间的，当请求越多的时候，传输的所花的时间也就越多。

其次，http的链接需要域名解析-开启tcp连接-发送请求-等待-下载资源-文件解析，这个过程的每个阶段都需要消耗时间。

[参考：](https://blog.csdn.net/chenchun91/article/details/52207008)

https比http慢是因为https多了一个ssl握手。

https和http都是建立在tcp协议之上，http经过三次握手之后就发送数据了。客户端首先发送SYN包，服务器收到之后发送SYN+ACK包给客户端，最后客户端再发送ACK包给服务器，接下来就发送内容了。

1. HTTP耗时 = TCP握手 
2. HTTPs耗时 = TCP握手 + SSL握手

##### http2与http1的区别

http2.0（超文本传输协议），主要是基于SPDY协议（是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提高网络速度，优化用户的网络体验）。

Http2 采用二进制格式而非文本格式

Http2是多路复用技术，而非有序阻塞的，只需要一个连接就可以实现并行

Hppt2支持对header数据的压缩

Http2让服务器可以将响应主动推送到客户端

## 1.9、事件冒泡与事件捕获

事件冒泡：当鼠标点击某个dom结点时（被触发这个点击事件的元素叫做事件源），浏览器会从事件源=》根节点进行从内到外传播。

事件捕获：根节点=〉事件源，从外到内传播。

dom标准事件流的触发的先后顺序为；先捕获再冒泡。即当触发dom事件时，会先从外到内进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。

addEventListener的第三个参数

addEventListener方法有三个参数，第一个参数是需要绑定的事件类型，第二个参数是触发事件后要执行的函数，第三个参数是布尔类型。

```javascript
element.addEventListener(event,function,useCapture);//capture捕获
```

useCapture默认是false，表示在事件冒泡阶段调用事件处理函数；如果参数是true，表示在事件捕获阶段调用处理函数。

##### 事件冒泡：

```javascript
<body>
  <div id="parent">
    父元素
    <div id="child">
      子元素
    </div>
  </div>
  <script type="text/javascript">
    var parent = document.getElementById("parent");
    var child = document.getElementById("child");

    document.body.addEventListener("click",function(e){
      console.log("click-body");
    },false);

    parent.addEventListener("click",function(e){
      console.log("click-parent");
    },false);

    child.addEventListener("click",function(e){
      console.log("click-child");
    },false);
  </script>
</body>
```

第三个参数是false，会在事件冒泡阶段处理函数，因此会（从内到外）从事件源=》根节点。上述代码执行的结果如下：

![image-20191127201622387](/Users/zhangtengfei9/Library/Application Support/typora-user-images/image-20191127201622387.png)

##### 阻止事件冒泡

如果点击元素不想传递到父元素，可以用event.stopPropagation()。

```javascript
child.addEventListener("click",function(e)){
     console.log("click-child");
			e.stopPropagation();
},false);
```

##### 事件捕获：

```javascript
var parent = document.getElementById("parent");
var child = document.getElementById("child");

document.body.addEventListener("click",function(e){
  console.log("click-body");
  },false);

parent.addEventListener("click",function(e){
  console.log("click-parent---事件传播");
},false);
    　　　　 
　　　　 //新增事件捕获事件代码
parent.addEventListener("click",function(e){
  console.log("click-parent--事件捕获");
},true);

child.addEventListener("click",function(e){
  console.log("click-child");
},false);
```

执行结果：

![image-20191128141446428](/Users/zhangtengfei9/Library/Application Support/typora-user-images/image-20191128141446428.png)

##### 事件委托

一般来讲就是会把一个或者一组元素的事件委托到它的父层或者更外层元素上，而真正绑定的是最外层的元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制触发到它的外层元素的绑定事件上，然后在外层元素上执行函数。

```html
<ul id="list">
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
  ......
  <li>item n</li>
</ul>
```

事件委托的好处：

1、减少内存消耗 提高性能

每一个事件函数都是需要内存消耗的，只需要在外层元素上添加一个事件的话内存消耗会更少。

2、动态绑定事件

使用事件委托可以自动绑定动态添加的元素。比如上述的例子，我们给每个列表项都绑定事件，在很多时间我们需要通过用户操作去动态的添加或者删掉列表项的元素，那么在每一次添加元素的时候都要新绑定事件，删除元素的时候需要删去元素的绑定事件；如果用了事件委托就不会有这种麻烦了。因为事件是绑定在父元素中的， 和目标元素的增减是没有关系的。

```javascript
<ul id="list">
  <li className="class-1">item 1</li>
  <li>item 2</li>
  <li className="class-1">item 3</li>
  ......
  <li>item n</li>
</ul>
<script>
document.getElementByid("list").addEventListener("click",function(e){
    var event = e || window.event;
    var target = event.target;
    if(target.matches("class-1")){
      console.log(target);
    }
  })
</script>
```

### 10、输入url浏览器经过哪些过程？

参考

https://juejin.im/entry/57f10284da2f60004f5f2e5e

https://juejin.im/post/5ad4094e6fb9a028d7011069

详细的https://zhuanlan.zhihu.com/p/43369093

主要过程：

**1、域名解析**

**2、TCP连接**

**3、发送HTTP请求**

**4、服务器处理请求并返回报文**

**5、浏览器解析渲染页面**

**6、连接结束**

这个问题是不是说得越详细越好呢？说的很详细面试官也可能会抓一个细的点而自己又不擅长的点问，其实可以说的细致一点 ，但是面试官如果抓到细致的点问可能了解一些就行，估计不要求多么的深刻的理解。细致的过程就是：

1、输入URL

2、域名解析，浏览器查找域名对用的IP地址，这是DNS的查找过程，首先会先向本地本地服务器请求，这时候本地服务器先去读取它的缓存，如果缓存中有此记录就返回缓存中的，如果没有就继续向域名服务器请求  

3、tcp连接

4、发送http请求

5、服务器处理请求

6、服务器返回一个http响应

7、浏览器解析渲染页面



**1、域名解析**

**2、建立tcp连接**

为什么要三次握手？

这是因为防止已经失效的请求报文突然又传到服务器，浪费资源，因而产生错误。

其中主要是**三次握手**

第一次握手：客户端发送syn包到服务器，进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到客户端发来的SYN包，同时自己发送一个SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包之后，想服务器发送确认包ACK，此包发送完之后客户端和服务器端进入ESTABLISHED状态，完成三次握手。

三次握手结束后客户端和服务器才开始传输数据。

**四次挥手**

挥手为什么要四次？

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

客户端发送FIN包，用来关闭客户端到服务器的传输

服务器收到这个FIN包，并发送一个ACK包

服务器关闭数据传输，发送一个FIN包给客户端

客户端发回ACK包确认。

TCP与UDP的区别都在网络的传输层。

[参考](https://segmentfault.com/a/1190000020610336)

**TCP与UDP的区别？**

TCP 与 UDP 的区别

1. TCP 是面向连接的协议，UDP 是无连接协议

TCP 发送数据前使用三次握手建立连接，UDP 发送数据前不需要建立连接。

2. TCP 可靠，UDP 不可靠

TCP 丢包会自动重传，UDP 不会(任何必需的可靠性必须由应用层来提供)。 TCP 可靠性由三个机制保证：1. 序号（TCP 报文的序号）2. 确认（ACK 机制）3. 重传（超时或者冗余的 ACK）

3. TCP 有序，UDP 无序

消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP 会对其进行重新排序，UDP 不会。

4.TCP 无界，UDP 有界

TCP 通过字节流传输，UDP 中每一个包都是单独的。

5. TCP 有流量控制（拥塞控制），UDP 没有

TCP 协议的流量控制是基于滑窗协议实现的。 拥塞控制和流量控制不同，流量控制是点对点的通信量抑制，抑制发送端发送速率，使得接收端来得及接收。

TCP 传输慢，UDP 传输快；

因为 TCP 需要建立连接、保证可靠性和有序性，所以比较耗时。 这就是为什么视频流、广播电视、在线多媒体游戏等选择使用 UDP。

TCP 是重量级的，UDP 是轻量级的

TCP 要建立连接、保证可靠性和有序性，就会传输更多的信息，如 TCP 的包头比较大。

- TCP 是面向连接的、可靠的、有序的、速度慢的协议；UDP 是无连接的、不可靠的、无序的、速度快的协议。
- TCP 开销比 UDP 大，TCP 头部需要 20 字节，UDP 头部只要 8 个字节。
- TCP 无界有拥塞控制，UDP 有界无拥塞控制。

|          | TCP      | UDP    |
| -------- | -------- | ------ |
| 连接性   | 面向连接 | 无连接 |
| 可靠性   | 可靠     | 不可靠 |
| 有序性   | 有序     | 无序   |
| 有界性   | 有界     | 无界   |
| 拥塞控制 | 有       | 无     |
| 传输速度 | 慢       | 快     |
| 量级     | 重量级   | 轻量级 |
| 头部大小 | 大       | 小     |

### 11、Generator

```javascript
function* gen(x){
	y = yield x+1;
	return y;
}
var g = gen(1);
g.next() // { value: 2, done: false }
g.next() // { value: undefined, done: true }
```

一个函数，参数是generation函数，怎么执行完所有generation中的yield呢？

```javascript
function run(f){
	for(let v of f()){
		console.log(v);
	}
};
function* g(){
	yield 1;
	yield 2;
	yield 3;
}
run(g)
```

### 12、获取页面中的所有img

```javascript
document.getElementsBytagName("img")
```

### 13、事件格式化为2小时前，一分钟前

```javascript
//JavaScript函数：
var minute = 1000 * 60;
var hour = minute * 60;
var day = hour * 24;
var halfamonth = day * 15;
var month = day * 30;
function getDateDiff(dateTimeStamp){
var now = new Date().getTime();
var diffValue = now - dateTimeStamp;
if(diffValue < 0){
 //若日期不符则弹出窗口告之
 //alert("结束日期不能小于开始日期！");
 }
var monthC =diffValue/month;
var weekC =diffValue/(7*day);
var dayC =diffValue/day;
var hourC =diffValue/hour;
var minC =diffValue/minute;
if(monthC>=1){
 result="发表于" + parseInt(monthC) + "个月前";
 }
 else if(weekC>=1){
 result="发表于" + parseInt(weekC) + "周前";
 }
 else if(dayC>=1){
 result="发表于"+ parseInt(dayC) +"天前";
 }
 else if(hourC>=1){
 result="发表于"+ parseInt(hourC) +"个小时前";
 }
 else if(minC>=1){
 result="发表于"+ parseInt(minC) +"分钟前";
 }else
 result="刚刚发表";
return result;
}
```

### 14、微信小程序原理

微信小程序是基于web规范

**小程序在三端的运行环境是不同的：**

ios：javaScriptCore

android：旧版本是x5,新版本是V8

在开发工具上：NW.js，node-webkit

**双线程模型：**小程序的渲染层和逻辑层分别是由2个线程管理，渲染层使用webview进行渲染，逻辑层使用jscore线程运行js脚本。

**通信问题：**小程序的逻辑层和渲染层的通信是由native(微信客户端)做中转的，逻辑层发送网络请求也经由native转发。

**视图层<->微信**

Ios:wkwebview提供的messageHandlers

Android:往 WebView 的 window 对象注入一个原生方法，最终会封装成 WeiXinJSBridge 这样一个兼容层，主要提供了调用（invoke）和监听（on）这两种方法。

**逻辑层<->微信**

iOS 平台可以往 JavaScripCore 框架注入一个全局的原生方法，而安卓方面则是跟渲染层一致的。

### 15、回流和重绘

[参考1:](https://segmentfault.com/a/1190000017329980)

[参考2:](https://juejin.im/post/5a9923e9518825558251c96a)

**回流一定会导致重绘。**

回流：浏览器构建渲染树，将可见的dom节点以及样式对应起来，可是我们还需要计算他们在设备视口中的确切位置和大小，这个计算的过程就是回流。

重绘：把每个节点转换为屏幕上实际的像素，这个阶段就是重绘节点。

什么情况下会导致回流呢？

- 页面首次渲染

- 浏览器窗口大小发生改变

- 元素尺寸或位置发生改变

- 元素内容变化（文字数量或图片大小等等）

- 元素字体大小变化

- 添加或者删除**可见**的`DOM`元素

- 激活`CSS`伪类（例如：`:hover`）

- 查询某些属性或调用某些方法

  什么情况下会导致重绘呢？

  当页面中元素样式的改变并**不影响它在文档流中的位置**时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘

浏览器的优化机制：

每次回流都会导致额外的计算造成计算消耗，因此浏览器会通过队列化批量进行回流过程。浏览器将要回流的操作加入到一个队列中，直到过一段时间或者达到一个阈值时，才清空队列。但是当你获取布局信息的时候会强制队列刷新，比如：

- offsetTop、offsetLeft、offsetWidth、offsetHeight
- scrollTop、scrollLeft、scrollWidth、scrollHeight
- clientTop、clientLeft、clientWidth、clientHeight
- getComputedStyle()
- getBoundingClientRect
- 具体可以访问这个网站：[https://gist.github.com/pauli...](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)

***怎样减少回流和冲毁重绘？***

1、避免使用table布局

2、将动画应用到position为absolute或者fixed的元素上。

3、避免过多的使用内联样式

4、使用css3硬件加速（GPU加速）

5、避免频繁的操作样式，最好一次性重写style属性

6、可以先设置元素的display:none，操作结束后再把他显示出来，因为在display属性为none的元素上进行dom的操作不会引起回流和重绘。

7、css3硬件加速，可以让transform、opacity、filters这些动画不会重绘，

重点

- 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘
- 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

#### css3硬件加速的坑

- 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。
- 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。

#### webpack

什么是webpack，weboack可以看作是模块打包机，

### 16、async await

[参考链接](https://segmentfault.com/a/1190000007535316)

### 17、webpack

webpack是一种模块化的解决方案，它可以分析你的项目结构将代码打包成适合浏览器加载的模块。他的公作方式是将项目当成一个整体，各一个主文件，webpack将从这个文件中找到你的项目中的所有的依赖文件，使用loaders处理它们，并在最后打包成一个或者多个浏览器可识别的js文件。

Loaders ：通过使用不同的loader，webpack调用外部的脚本或者是工具，实现对不同格式的文件的处理，比如说拆分scss为css，或者把es6/es7代码转换成现代浏览器兼容的js代码，或者把jsx代码转换成js代码。loader一般有test（处理文件的扩展名的正则表达式）和loader（loader名字）属性；常见的loader style-loader/css-loader/post-css/babel-loader

Plugins：是用来扩展webpack的功能的，他和loader完全是不同的东西，loader是在项目打包的过程中处理scss/jsx/less文件的，插件plugins并不会直接处理这些文件，他是直接对整个构建过程起作用。

HtmlWebpackPlugin:可以动态的引入js,因为每次打包后的js hash值可能不一样，它可以根据具体的hash值

HotModuleReplacementPlugin：模块热替换插件

SplitChunksPlugin ,代码分割插件

### 观察者模式

观察者模式又称为发布订阅模式，是行为模式的一种，它定义了一对多的依赖关系，让多个观察者对象监听一个主题对象，这个主题对象的状态发生变化时，对通知所有的观察者对象，是他们自己自动更新。

包括抽象观察者和具体观察者，抽象主题和具体主题

使用场景：关联行为场景/事件多级出发场景/

优点：解除耦合，让耦合的双方都依赖抽象，从而使得各自的变换不会影响另一边。

缺点：使用观察者模式应该考虑开发效率和y n



### 13、git merge 和 rebase

merge 是合并的意思，rebase是复位基底的意思。
现在我们有这样的两个分支,test和master，提交如下：

```bash
     D---E test
    /
A---B---C---F master
```

在master执行`git merge test`然后会得到如下结果：

```bash
     D--------E
    /          \
A---B---C---F---G    test , master
```

在master执行`git rebase test`,然后得到如下结果：

```bash
 A---C---D---E---C `---F` test , master
```

可以看到merge操作会生成一个新的节点，之前提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的操作。

通过上面可以看到，想要更好的提交树，使用rebase操作会更好一点，这样可以线性的看到每一次提交，并且没有增加提交节点。
 在操作中。merge操作遇到冲突时候，当前merge不能继续下去。手动修改冲突内容后，add 修改，commit 就可以了
 而rebase操作的话，会中断rebase，同时会提示去解决冲突。解决冲突后，将修改add后执行git rebase -continue继续操作，或者git rebase -skip忽略冲突。

###  14、let const var

var的话会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针

let的话，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错

const的话，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性

### 15、实现bind方法

https://juejin.im/post/5b00f146f265da0b7e0c8a54

```
let obj = {
  ll: 'seve'
};

Function.prototype.bind = function(that) {
  var self = this;
  return function() {
    return self.apply(that, arguments);
  };
};
let func0 = function(a, b, c) {
  console.log(this.ll);
  console.log([a, b, c]);
}.bind(obj, 1, 2);

func0(3); // seve
```

#### es6 进阶版

es6 提供了结构运算符，可以很方便的利用其功能实现 bind

```
Function.prototype.bind = function(that, ...argv) {
  if (typeof this !== 'function') {
    throw new TypeError(`${this} is not callable`);
  }
  // 保存原函数
  let self = this;
  // 获取bind后函数传入的参数
  return function(...argu) {
    return self.apply(that, [...argv, ...argu]);
  };
};
let func1 = function(a, b, c) {
  console.log(this.ll);
  console.log([a, b, c]);
}.bind(obj, 1, 2);

func1(3); // seve
// [ 1, 2, 3 ]
复制代码
```

es6 版实现很简单对吧，但是面试官说我们的运行环境是 es5，这时你心中窃喜，bable 大法好，但是你可千万不要说有 babel，因为面试官的意图不太可能是问你 es6 如何转换成 es5，而是考察你其他知识点，比如下面的类数组如何转换为真正的数组

#### es5 进阶版

```
Function.prototype.bind = function() {
  if (typeof this !== 'function') {
    throw new TypeError(`${this} is not callable`);
  }
  var self = this;
  var slice = [].slice;
  // 模拟es6的解构效果
  var that = arguments[0];
  var argv = slice.call(arguments, 1);
  return function() {
    // slice.call(arguments, 0)将类数组转换为数组
    return self.apply(that, argv.concat(slice.call(arguments, 0)));
  };
};
let func2 = function(a, b, c) {
  console.log(this.ll);
  console.log([a, b, c]);
}.bind(obj, 1, 2);

func2(3); // seve
// [ 1, 2, 3 ]
复制代码
```

当然，写到这里，对于绝大部分面试，这份代码都是一份不错的答案，但是为了给面试官留下更好的印象，我们需要上终极版 实现完整的bind函数，这样还可以跟面试官吹一波

#### 终极版

为了当使用new操作符时，bind后的函数不丢失this。我们需要把bind前的函数的原型挂载到bind后函数的原型上

但是为了修改bind后函数的原型而对bind前的原型不产生影响，都是对象惹的祸。。。直接赋值只是赋值对象在堆中的地址 所以需要把原型继承给bind后的函数，而不是直接赋值，我有在一些地方看到说Object.crate可以实现同样的效果，有兴趣的可以了解一下，但是我自己试了下，发现效果并不好，new 操作时this指向错了(可能是我使用姿势错了)

**通过直接赋值的效果**

```
Function.prototype.bind = function(that, ...argv) {
  if (typeof this !== 'function') {
    throw new TypeError(`${this} is not callable`);
  }
  // 保存原函数
  let self = this;
  let func = function() {};
  // 获取bind后函数传入的参数
  let bindfunc = function(...arguments) {
    return self.apply(this instanceof func ? this : that, [...argv, ...arguments]);
  };
  // 把this原型上的东西挂载到func原型上面
  // func.prototype = self.prototype;
  // 为了避免func影响到this，通过new 操作符进行复制原型上面的东西
  bindfunc.prototype = self.prototype;

  return bindfunc;
};

function bar() {
  console.log(this.ll);
  console.log([...arguments]);
}
let func3 = bar.bind(null);

func3.prototype.value = 1;

console.log(bar.prototype.value) // 1    可以看到bind后的原型对bind前的原型产生的同样的影响
复制代码
```

**通过继承赋值的效果**

```
Function.prototype.bind = function(that, ...argv) {
  if (typeof this !== 'function') {
    throw new TypeError(`${this} is not callable`);
  }
  // 保存原函数
  let self = this;
  let func = function() {};
  // 获取bind后函数传入的参数
  let bindfunc = function(...argu) {
    return self.apply(this instanceof func ? this : that, [...argv, ...argu]);
  };
  // 把this原型上的东西挂载到func原型上面
  func.prototype = self.prototype;
  // 为了避免func影响到this，通过new 操作符进行复制原型上面的东西
  bindfunc.prototype = new func();

  return bindfunc;
};

function bar() {
  console.log(this.ll);
  console.log([...arguments]);
}
let func3 = bar.bind(null);

func3.prototype.value = 1;

console.log(bar.prototype.value) // undefined   可以看到bind后的原型对bind前的原型不产生影响

func3(5);     // seve
              // [ 5 ]
new func3(5); // undefined
              // [ 5 ]
```

### 17、防抖与节流

**## 什么是防抖和节流**

先抛出防抖与节流的概念：

***\*防抖(debounce):在任务频繁触发的情况下，只有任务触发的时间间隔超过指定间隔的时候，任务才会执行。\****（在时间间隔内不论你你点击多少次，我根本就不予理会。）

如下图所示，红线表示触发事件，触发事件的频率是0.5s，设置防抖的时间间隔是1s，见如此时每隔0.5s触发一次事件，在10s内不会事件一次都不会成功触发。

<img src="/img/debounce-1.jpg"  />灰色表示的是事件触发的情况，因为始终没法等1s就被再次触发了，所以最终没有一次事件是成功的。

***\*节流(throttle)：指定时间间隔内只会执行一次任务。\****(每隔特定的时间就执行一次，不管你在这个特定时间内触发事件多少次，我只执行一次)

如下图所示，红线表示触发事件，绿线表示成功触发该事件，触发事件的频率是0.5s，设置节流的时间间隔是1s，可以看到每隔1s，事件会成功触发一次。

<img src="/img/debounce-2.jpg"  />

**## 防抖与节流的实现**

不知怎地，防抖和节流让我不由自主的想起雪姨敲门的情景，下面就拿雪姨敲门举例。

**### 防抖：**

原理：防抖的原理是设置一个定时器，并给定时器设置一个定时的时间值，当频繁的触发请求函数时，下一次执行的函数会在执行时把上次延迟还没执行的函数清空，所以，只要不停的在定时器的默认时间值内触发函数，就会请求函数就会一直被清除，直到最后一次成功触发。

对于函数防抖，有以下几种应用场景：

1、给按钮加函数防抖防止表单多次提交。

2、对于输入框连续输入进行AJAX验证时，用函数防抖能有效减少请求次数。

3、判断scroll是否滑到底部，滚动事件+函数防抖

```
function _debounce(fn,wait){
​    var timer = null;
​    return function(){
​        clearTimeout(timer)
​        timer = setTimeout(()=>{
​            fn()
​        },wait)
​    }
}

function out(){
  console.log(Math.random())
   //console.log(document.getElementById('input').value)

}
setInterval(_debounce(out,1000),500) //雪姨每隔500ms就敲一次门，但是主人公心里想：你就敲吧，只要不大于1000ms，我就不开门！

//setInterval(_debounce(out,1000),1001) // 敲不开门没有办法了,雪姨决定作出让步,1001s敲一次，终于，门开了！此后，每隔1001ms会开一次门

function clearfun(){
  console.log('ddd')
  document.getElementById('input').value='';
}
```

实际的应用场景举例：

```javascript
document.getElementById('input').oninput = _debounce(out,500)
function _debounce(fn,wait){
​    var timer = null;
​    return function(){
​        clearTimeout(timer)
​        timer = setTimeout(()=>{
​            fn()
​        },wait)
​    }
}

//ajax请求函数

function ajax(){
   console.log(document.getElementById('input').value)
}
```

### 节流：

原理：节流就是判断当前这次的函数触发时间和上次的函数触发时间的时间差是否大于规定的延迟时间值，若大于就成功触发函数。

对于函数节流，有如下几个场景：

1、游戏中的刷新率

2、DOM元素拖拽

3、Canvas画笔功能

时间戳版：

```javascript
function throttle(fn, gapTime) {
  let _lastTime = null;
  return function () {
​    let _nowTime = + new Date()
​    if (_nowTime - _lastTime > gapTime || !_lastTime) {
​      fn();
​      _lastTime = _nowTime
​    }
  }
}

function out(){
  console.log(Math.random())
   //console.log(document.getElementById('input').value)
}
```

setInterval(throttle(out,1000),10) // 雪姨还是暴脾气，每隔10ms敲一次门，门里面的人也改变了规则，无论你怎么敲门，我每隔1000ms给你开一次门

\```

定时器版:

```javascript
function throttle(func, wait) {
​    let timeout;
​    return function() {
​        let context = this;
​        let args = arguments;
​        if (!timeout) {
​            timeout = setTimeout(() => {
​                timeout = null;
​                func.apply(context, args)
​            }, wait)
​        }
​    }
}
```

时间戳版和定时器版的节流函数的区别:时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。

将时间戳版和定时器版的节流函数结合起来，实现双剑合璧版的节流函数。

双剑合璧版:

```javascript
/**

 \* @desc 函数节流

 \* @param func 函数

 \* @param wait 延迟执行毫秒数

 \* @param type 1 表时间戳版，2 表定时器版

 */

function throttle(func, wait ,type) {
​    if(type===1){
​        let previous = 0;
​    }else if(type===2){
​        let timeout;
​    }
​    return function() {
​        let context = this;
​        let args = arguments;
​        if(type===1){
​            let now = Date.now();
​            if (now - previous > wait) {
​                func.apply(context, args);
​                previous = now;
​            }
​        }else if(type===2){
​            if (!timeout) {
​                timeout = setTimeout(() => {
​                    timeout = null;
​                    func.apply(context, args)
​                }, wait)
​            }
​        }
​    }
}
```

### 18、深拷贝浅拷贝

**js中数据的存储**

先总结一下js中数据的类型和数据的存储方式；

**数据类型**

基本类型：undefined、null、boolean、number、string、Symbol

引用类型：Object

**数据存储方式**

js中数据有两种存储方式：***栈存储和堆存储***。其中基本数据类型主要放在栈中，引用类型主要放在堆中。

***栈内存***：基本类型在内存中占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。

***堆内存***：引用类型的地址是固定大小的，存储在栈内存中，引用类型的值大小是不固定的，所以，值是存在堆内存中的。

**浅拷贝**

浅拷贝MDN并没有给出明确的定义。

根据自己的理解，***浅拷贝（浅复制）主要拷贝的数据类型是对象，浅拷贝只拷贝对象的第一层的属性，如果拷贝的对象有子对象，那么浅拷贝并不会递归的拷贝其子对象的属性。***

```javascript
var obj1={
​    id:1,
​    arr:[1,2]
}

function copy(obj){
​    var o={}
​    for (var prop in obj){
​        if(obj.hasOwnProperty){
​            o[prop]=obj[prop]
​        }
​    }
​    return o;
}

obj2=copy(obj1);

obj2.id=2;
obj2.arr[0]=0

obj1.id//1
obj2.id//2

obj1.arr//[0,2]
obj2.arr//[0,2]
```

**深拷贝**

***它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。***

**利用递归实现深拷贝(多层对象)**

```java
var obj1={
​    id:1,
​    arr:[1,2]
}

function copy(obj){
​    var o={}
​    for (var prop in obj){
​        if(obj.hasOwnProperty){
​            if(typeof(obj[prop])==='object'){
​                o[prop]=obj[prop].constructor===Array?[]:{};
​                o[prop]=copy(obj[prop])
​            }else{
​                o[prop]=obj[prop]
​            }
​        }
​    }
​    return o;
}
obj2=copy(obj1);

obj2.id=2;
obj2.arr[0]=0

obj1.id//1
obj2.id//2

obj1.arr//[1,2]
obj2.arr//[0,2]
```

** JSON.parse(JSON.stringify(XXXX))实现对象的深拷贝(多层对象) **

JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝。

参考[javaScript中浅拷贝和深拷贝的实现](https://github.com/wengjq/Blog/issues/3)

```java
var obj1={
​    id:1,
​    arr:[1,2]
}
function copy(obj){
​    var o={}
​    o=JSON.parse(JSON.stringify(obj))
​    return o;
}
obj2=copy(obj1);
```

**### es6扩展运算符(...)实现对象的深拷贝(一层对象)**

```java
var obj1={
​    id:1,
​    name:'zhang'
}
obj2={...obj1};
```

**### ES6的Object.assign(一层对象)**

```java
var obj1={
​    id:1,
​    arr:[1,2]
}

function copy(obj){
​    var o={}
​    o=Object.assign({},obj);
​    return o;
}

obj2=copy(obj1);
```

```java
**### slice方法深拷贝数组**
因为slice不是在原数组上修改，而是会返回新的数组。
var arr1=[1,2,3,4,5];
var arr2=arr1.slice(0);
arr2.push(6);
console.log(arr1);//[1, 2, 3, 4, 5]
console.log(arr2);//[1, 2, 3, 4, 5, 6]

**### concat方法，因为concat不是在原数组上修改，而是会返回新的数组**
var arr1=[1,2,3,4,5];
var arr2=arr1.concat();
arr2.push(6);
console.log(arr1);//[1, 2, 3, 4, 5]
console.log(arr2);//[1, 2, 3, 4, 5, 6]


**### es6提供的方法 Array.from()**
var arr1=[1,2,3,4,5];
var arr2=Array.from(arr1);
arr2.push(6);
console.log(arr1);//[1, 2, 3, 4, 5]
console.log(arr2);//[1, 2, 3, 4, 5, 6]
```

### 19、数组去重

[参考](https://segmentfault.com/a/1190000016418021)

#### 1.19.1 用includes方法判断，该方法采用的是samevaluezero规则：

```javascript
let arr = [1, "1", "a", {}, {}, { a: 1 }, {}, { a: 1 }, [], [], [1], undefined, null, NaN];
function uniq(arr) {
    let res = [];
    for (let i = 0; i < arr.length; i++) {
        if (!res.includes(arr[i])) {
            res.push(arr[i]);
        }
    }
    return res;
}
```

#### 1.19.2 用Map数据类型

```javascript
function uniq(arr){
	let res = [];
  let map = new Map();
	for(let i =0;i<arr.length;i++){
		!map.has(arr[i])&& map.set(arr[i],true)
	}
	return [...map.keys()];
}
```

#### 1.19.3 用Set数据类型

```java
function uniq(arr){
	return [...new Set(arr)]
}
```

Set与Map类似，但是set不存value的值，key同样不能重复。

filter

```java
function uniq(arr){
	return arr.filter(function(item,index,arr){
		return arr.indexOf(item) === index;
	})
}
```

#### 1.19.4用对象的属性

```js
function unique(arr){
	if(!Array.isArray(arr)){
		return;
	}

	var result = [];
	var obj = {};
	for(let i=0;i<arr.length;i++){
		if(!obj[arr[i]]){
			obj[arr[i]] = 1;
			result.push(arr[i])
		}else{      
			obj[arr[i]]++
		}
	}
	return result;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
```

#### 1.19.5 indexof

```jsx
function unique(arr){
    var array = [];
    for(let i=0;i<arr.length;i++){
        if(array.indexOf(arr[i]) == -1){
            array.push(arr[i])
        }
    }
    return array;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
```

#### 1.19.6 sort

```jsx
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return;
    }
    arr = arr.sort()
    var arrry= [arr[0]];
    for (var i = 1; i < arr.length; i++) {
        if (arr[i] !== arr[i-1]) {
            arrry.push(arr[i]);
        }
    }
    return arrry;
}
     var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
// [0, 1, 15, "NaN", NaN, NaN, {…}, {…}, "a", false, null, true, "true", undefined]      //NaN、{}没有去重
```

#### 1.19.7 filter

```js
function unique(arr){
	var array = [];
	arr.filter((item,index,arr)=>{
		return arr.indexOf(item) === index;
	});
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
//[1, "true", true, 15, false, undefined, null, "NaN", 0, "a", {…}, {…}]
```

### 20、前端安全

#### 1.20.1 XSS跨站脚本攻击

XSS(cross site script)跨站脚本攻击是最常见的攻击web网站的方法，攻击者通过注入非法的脚本代码到网页中，实现对用户浏览器的控制。

一般分为三种：

+ 存储型XSS。存储行XSS攻击方式也叫做持久性XSS，这种攻击的代码会被服务器写入数据库，这种危害是最大的，因为网站访问量比较大的话就会导致大量的用户访问都会收到攻击，典型的例子就是留言板。
+ 反射型XSS。反射型XSS也叫非持久化XSS，这种是最容易出现的XSS漏洞，一般是通过修改URL的参数方式攻击代码，诱导用户访问链接，最后输入提交到服务器，服务器在解析后在响应内容中初次安这段XSS代码，最后在浏览器中解析执行。
+ DOM XSS。使用DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。这种方式不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。

#### 1.20.2 防御对策

+ 转移字符

+ CSP建立白名单，设置http header中的content-security-policy或者设置meta标签<meta http-equiv="content-security-policy">

  DOM型和前两种攻击类型的区别是：前两种类型属于服务器端的安全漏洞，DOM型取出和执行恶意代码完全由浏览器完成，属于前端自身的安全漏洞。
  XSS的攻击预防措施主要是转义，转义用改在后台输出HTML时进行，而不是在用户输入提交时候进行。不同的上下文需要的转义规则不一样。
  XSS的检测：
  手动检测：特定字符串“jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert()//>\x3e”
  自动检测：Arachni、Mozilla、
  减少漏洞的产生：利用模板引擎（ejs/dot.js）、避免内联事件，使用addEventListener()、避免拼接HTML。

#### 1.20.3 CSRF跨站请求伪造

原理就是攻击者伪造一个后端地址诱导用户点击回这是通过某些途径发起请求，或者是冒充用户发起请求，后台以为是用户在操作，进行了相应的返回逻辑。

举个栗子，假设网站中有一个通过 GET 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口。

```javascript
<img src="http://www.domain.com/xxx?comment='attack'"/>
```

那么你是否会想到使用 POST 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 POST 请求。

##### 1.20.3.1 如何防御

防范 CSRF 攻击可以遵循以下几种规则：

- Get 请求不对数据进行修改
- 不让第三方网站访问到用户 Cookie
- 阻止第三方网站请求接口
- 请求时附带验证信息，比如验证码或者 Token

##### SameSite

可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。

##### 验证 Referer

对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。

##### Token

服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。

####1.20.4 点击劫持

点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。

##### 1.20.4.1 防御策略

对于这种攻击方式，推荐防御的方法有两种。

##### X-FRAME-OPTIONS

X-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。
 该响应头有三个值可选，分别是

- DENY，表示页面不允许通过 iframe 的方式展示
- SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示
- ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示

##### jS 防御

对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。

```html
<head>
   <style id="click-jack">
     html {
       display: none !important;
     }
   </style>
</head>
<body>
   <script>
     if (self == top) {
       var style = document.getElementById('click-jack');
       document.body.removeChild(style);
     } else {
       top.location = self.location;
     }
   </script>
</body>
```

以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。

#### 1.20.5 中间人攻击

攻击方同时与服务端和客户端都建立了联系，整个过程都被攻击者控制了，例如公共场所的wifi，https可以防御中间人攻击，但是并不是https旧高枕无忧了，如果没有完全关闭http访问的话，攻击方可以通过降级https的方式实现这中间人攻击。

### 21 内存泄漏？

什么是内存泄漏呢？由于逻辑疏忽造成程序中已经不再使用的内存，没有及时的释放，导致的资源浪费。

什么情况下会导致内存泄漏呢？

[https://github.com/zhansingsong/js-leakage-patterns/blob/master/%E5%B8%B8%E8%A7%81%E7%9A%84JavaScript%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/%E5%B8%B8%E8%A7%81%E7%9A%84JavaScript%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2.md](https://github.com/zhansingsong/js-leakage-patterns/blob/master/常见的JavaScript内存泄露/常见的JavaScript内存泄露.md)

[JS内存泄漏排查方法](https://cloud.tencent.com/developer/article/1444558)

[闭包会造成内存泄漏吗](https://segmentfault.com/a/1190000007315908)

1、隐式的全局变量

2、计时器timer

3、游离的dom

4、闭包

闭包并不是内存泄漏的根本原因，根本原因是在ie9之前的的版本，dom和bom中的对象是以com对象实现的，而com对象的垃圾回收机制采用的是引用计数，虽然ie的javascrip采用的是标记清除策略，但是访问com对象仍然是基于引用计数的。闭包并不会引起内存泄漏，只是由于IE9之前的版本对JScript对象和COM对象使用不同的垃圾收集，从而导致内存无法进行回收，这是IE的问题，所以闭包和内存泄漏没半毛钱关系。

#### js中面向对象的理解

js中的面向对象和java等传统的面向对象不同，传统的面向对象中有类的概念，抽象的实例对象的实例和方法，基于类可以创建多个实例对象，并且有封装、集成、多态的特点。但是js中的对象就是一个无序属性的集合，这个属性可以是基本值、对象或者方法。每个属性或者方法都有一个名字，根据这个名字可以映射相对应的值。

### 22 window的onload事件和domcontentloaded谁先谁后？

https://www.cnblogs.com/caizhenbo/p/6679478.html

domcontentloaded先触发，onload后触发。

domcontentloaded是在dom内容加载完毕之后触发，或者说是html文档被加载和解析完成。这个解析的过程中如果有<script>标签，就会停止解析过程，去处理脚本，等待脚本处理完成后再继续解析html文档。domcontentloaded的触发不需要等待图片等其他资源加载完成。

load是在所有的资源加载完成之后才触发，包括图片、音频、视频等。

load事件在所有的浏览器都支持

domcontentloaded需要做兼容，ie6/ie7不支持domcontentloaded，但是他们支持onreadystatechange事件。

css为什么要放在头部，js脚本放在尾部？

css文件不会堵塞html文档的解析，但是会堵塞html的渲染。在加载html文档生成dom树，同时css生成cssom，然后dom和cssdom会生成渲染树，这样可以防止闪跳，白屏或者布局混乱。

假如我们将js放在header，js将阻塞解析dom。其次，javascript可能会改变DOM tree的结构，所以需要一个稳定的DOM tree。

我们在 jQuery 中经常使用的 $(document).ready(function() { // ...代码... }); 其实监听的就是 DOMContentLoaded 事件，而$(document).load(function() { // ...代码... }); 监听的是 load 事件。在用jquery的时候，我们一般都会将函数调用写在ready方法内，就是页面被解析后，我们就可以访问整个页面的所有dom元素，可以缩短页面的可交互时间，提高整个页面的体验。

### 23 数组扁平化

reduce

```js
function flatten(arr){
 return arr.reduce((result,item)=>{
 return result.concat(Array.isArray(item)?flaten(item),item)
 },[])
}
```

 先转成字符串再转成数组

```js
function flatten(arr){
 return arr.toString().split(',').map(item=>{
 return Number(item);
 })
}
```

```js
function flatten(arr){
 return arr.join(',').split(',').map(item=>{
 return parseInt(item)
 })
}
```

递归

```js
function flatten(arr){
 var result = [];
 arr.map(item=>{
 if(Array.isArray(item)){
  result = result.concat(flatten(item));
 }else{
  result.push()
 }
 })
 return result;
}
```

```js
function flatten(arr){
 while(arr.some(item=>Array.isArray(item))){
 arr = [].concat(...arr)
 }
 return arr;
}
```

https://juejin.im/post/5adc8e396fb9a07aa0479725

es10新特性

```js
let multi = [1,2,3,[4,5,6,[7,8,9,[10,11,12]]]];
multi.flat();               // [1,2,3,4,5,6,Array(4)]
multi.flat().flat();        // [1,2,3,4,5,6,7,8,9,Array(3)]
multi.flat().flat().flat(); // [1,2,3,4,5,6,7,8,9,10,11,12]
multi.flat(Infinity);       // [1,2,3,4,5,6,7,8,9,10,11,12]
```

### 24 js new 操作符

1、创建一个实例对象

2、执行构造函数

3、构造函数中的this上下文指向对象实例

4、返回this新对象本身

### 25 0.1+0.2！= 0.3

这是因为二进制在转换的时候精度缺失造成的。

js遵循IEEE754双精度64位来表示一个数字，其中0是符号位，1-11是指数位，12-63是尾数也就是有效数字，0.1转换成二进制的时候是1.XXXXXXXX这种无限循环的形式，这个时候后面的数字会被截断。因此会出现0.1+0.2！=0.3的情况。

### 26 柯里化函数

es5实现

```javascript
function curry(fn ,arr = []){
	return fn.length === arr.length ? fn.apply(null,arr) : function(...args){
    return curry(fn,arr.concat(...args));
  }
}
function fn(a,b,c){
	return a+b+c;
}
var add = curry(fn);
```

es6实现

```javascript
const curry = (fn,arr = [])=>{
	fn.length === arr.length ? fn.apply(null,arr) : (...args)=>{
		curry(fn,arr.concat(args))
	}
}
const fn = (a,b,c)=>{
  return a+b+c;
}
const add = curry(fn);
```

前面的两种是依赖参数个数的，下面的这种是不限制参数个数的

```javascript
var curry = function(fn) {
    var func = function() {
        var _args = [].slice.call(arguments, 0);
        var func1 = function() {
            [].push.apply(_args, arguments)
            return func1;
        }
        func1.toString = func1.valueOf = function() {
            return fn.apply(fn, _args);
        }
        return func1;
    }
    return func;
}
var add = function() {
    return [].reduce.call(arguments, function(a, b) {
        return a + b;
    })
}
var adder = curry(add)
adder(1)(2)(3)(4)(5)(6)(7)
```

偏函数和柯里化函数的区别是 偏函数是固定一个或者多个参数，将n元函数转换成n-x元函数，柯里化函数是将多参数函数转换成n个一元函数。
[参考](https://www.jianshu.com/p/5a565c707cd4)

### 27 纯函数和函数的副作用

纯函数：函数的返回值只依赖它的入参；函数在执行的过程中没有副作用

函数的副作用：发送网络请求、改变dom、打印log改变文件系统、改变函数作用域外的值等。

### 28 发布订阅模式

观察者模式又称为发布订阅模式，是行为模式的一种，它定义了一对多的依赖关系，让多个观察者对象监听一个主题对象，这个主题对象的状态发生变化时，对通知所有的观察者对象，是他们自己自动更新。

包括抽象观察者和具体观察者，抽象主题和具体主题

使用场景：关联行为场景/事件多级出发场景/

优点：解除耦合，让耦合的双方都依赖抽象，从而使得各自的变换不会影响另一边。

缺点：使用观察者模式应该考虑开发效率和y n

```javascript
发布订阅模式
var shoeObj = {}; // 定义发布者
shoeObj.list = []; // 缓存列表 存放订阅者回调函数
        
// 增加订阅者
shoeObj.listen = function(fn) {
    shoeObj.list.push(fn);  // 订阅消息添加到缓存列表
}

// 发布消息
shoeObj.trigger = function(){
    for(var i = 0,fn; fn = this.list[i++];) {
        fn.apply(this,arguments); 
    }
}
// 小红订阅如下消息
shoeObj.listen(function(color,size){
    console.log("颜色是："+color);
    console.log("尺码是："+size);  
});

// 小花订阅如下消息
shoeObj.listen(function(color,size){
    console.log("再次打印颜色是："+color);
    console.log("再次打印尺码是："+size); 
});
shoeObj.trigger("红色",40);
shoeObj.trigger("黑色",42);
```

### 29 求数组深度

```javascript
function depth(arr){
	if(typeof arr != 'object')return 0;
	arr.forEach( (item, i) =>{
        a.push(depth(item))
    })
    let maxDepth = Math.max(...a)
    return maxDepth+1;    
}
```

### 30 Proxy代理

```javascript
var man = {
    name:'ztf',
    age:22
}
var proxy = new Proxy(man,{
    get:function(target,property){
        if(property in target){
            return target[property];
        }else{
            throw new ReferenceError(`Property ${property} does not exist`)
        }
    }
})
console.log(proxy.p)//
```

proxy共有13个属性方法

- **get(target, propKey, receiver)**：拦截对象属性的读取，比如`proxy.foo`和`proxy['foo']`。
- **set(target, propKey, value, receiver)**：拦截对象属性的设置，比如`proxy.foo = v`或`proxy['foo'] = v`，返回一个布尔值。
- **has(target, propKey)**：拦截`propKey in proxy`的操作，返回一个布尔值。
- **deleteProperty(target, propKey)**：拦截`delete proxy[propKey]`的操作，返回一个布尔值。
- **ownKeys(target)**：拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`、`for...in`循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而`Object.keys()`的返回结果仅包括目标对象自身的可遍历属性。
- **getOwnPropertyDescriptor(target, propKey)**：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象。
- **defineProperty(target, propKey, propDesc)**：拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。
- **preventExtensions(target)**：拦截`Object.preventExtensions(proxy)`，返回一个布尔值。
- **getPrototypeOf(target)**：拦截`Object.getPrototypeOf(proxy)`，返回一个对象。
- **isExtensible(target)**：拦截`Object.isExtensible(proxy)`，返回一个布尔值。
- **setPrototypeOf(target, proto)**：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
- **apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。
- **construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`。

### 31 setTimeout、setInterval和requestAnimationFrame

setTimeout和setInterval的问题是，它们都不精确。它们的内在[运行机制](http://www.cnblogs.com/xiaohuochai/p/5773183.html#anchor3)决定了时间间隔参数实际上只是指定了把动画代码添加到浏览器UI线程队列中以等待执行的时间。如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行.

equestAnimationFrame采用系统时间间隔，保持最佳绘制效率，不会因为间隔时间过短，造成过度绘制，增加开销；也不会因为间隔时间太长，使用动画卡顿不流畅，让各种网页动画效果能够有一个统一的刷新机制，从而节省系统资源，提高系统性能，改善视觉效果。

　　【1】requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率

　　【2】在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量

　　【3】requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销

[参考链接](https://www.cnblogs.com/xiaohuochai/p/5777186.html)

### 32 异步编程的六种方案

回调函数、事件监听、发布订阅、promise、generators、async/await

**为什么 Async/Await 更好？**

1. 简洁2. 错误处理

[async/await比promise好](https://blog.fundebug.com/2017/04/04/nodejs-async-await/)

## 33 arguments是什么

arguments不是真正的数组。没有数组的方法

```jsx
function a(){
  console.log(arguments);
  var args = Array.prototype.slice.call(arguments);
  console.log(args);
  /* arguments.forEach(function(){   
  }) */
}
a(1,2,3)
```

## 1.34 _proto_与prototype

实例的__proto__属性指向其构造函数的原型**prototype**

```
函数也是一种对象，其同时具有 prototype 与 __proto__ 两个属性
prototype属性是函数特有，对象没有该属性
```

```javascript
class Parent {
    constructor(name) {
        this.name = name;
    }
    print() {
        console.log(this.name);
    }
}
let parent = new Parent('小明');
parent.__proto__ == Parent.prototype // true
```



# 二、css

## 2.1 flex弹性布局

flex存在两根轴，水平的主轴和垂直的交叉轴，主轴开始的位置是main start，结束的位置是main end；交叉轴开始的位置是cross start，交叉轴结束的位置是cross end。***默认延主轴排列***

采用flex布局的元素称为flex容器

```css
.box{
	display:flex;
}
```

容器的属性：

flex常用的6个属性是：flex-direction表示的是主轴的方向；flex-wrap：表示的是如何换行；flex-flow：表示的是前两者的合并；justify-content：表示的是在主轴上的排列方式；align-items：表示的是在交叉轴上的排列方式；align-content：表示的是多根轴线的对齐方式，如果只有一根轴线，这个属性不起作用。

### 2.1.1 flex-direction

flex-direction决定主轴的方向。

```scss
.box{
	display:flex;
	flex-direction:row/row-reverse/column/column-reverse
}
```

* row：默认值，代表的是主轴沿水平方向，起点在左端；
* row-reverse：代表的是主轴沿水平方向，起点在右端；
* column：代表的是主轴沿垂直方向，起点在上面；
* column-reverse：代表的是主轴沿垂直方向，起点在下面。

### 2.1.2 flex-wrap

flex-wrap含义是如何换行。

flex-wrap可以取3个值：

* nowrap：默认值，不换行；
* wrap：换行，第一行在上面；
* wrap-reverse：换行，第一行在下面。

### 2.1.3 flex-flow

flex-flow属性是flex-direction和flex-wrap的简写形式，或者说是结合形式。默认值为

flex-flow：row,nowrap;

```css
.box{
	display:flex;
	flex-flow:<flex-direction> <flex-wrap>;
}
```

### 2.1.4 justify-content

Justify-content属性定义了元素在主轴的对齐方式。可以取5个值：

* flex-start：默认值，代表的是左对齐；
* center：代表的是居中
* flex-end：代表的是右对齐；
* space-around：代表的是每个元素之间的间隔相同。所以元素之间的间隔距离是元素与边框间隔距离的两倍；
* space-between：代表的是两端对齐，元素之间的间隔相等。最边上的两个元素是贴着边框的。

```css
.box{
	display:flex;
	justify-content:flex-start/flex-end/center/space-around/space-between
}
```

### 2.1.5 align-items

align-items可以定义在交叉轴上怎么对齐，可以取5个值：

* flex-start：代表的是在交叉轴起点（上面）对齐；
* flex-end：代表的是在交叉轴终点（下面）对齐；
* center：代表的是在交叉轴中间对齐；
* baseline：以元素的第一行文字的基线对齐，也就是底部对齐；
* stretch：（默认值）如果元素为设置高度或者是高度设置为auto，将沾满整个容器的高度。

### 2.1.6 align-content

该属性用法比较特殊，只有在容器有多行轴线的时候才起作用，一行轴线不起作用。align-content可以取6个值。

align-content与along-items的区别是前者是对多行起作用，后者是对单行起作用，例如两者都设置为center时，前者表示的是多行元素在整个容器中居中，后者表示的是每一行元素在所在行居中。

+ flex-start：代表的是与交叉轴的起点对齐
+ flex-end：代表的是与交叉轴的终点对齐
+ center：代表的是与交叉轴的中点对齐
+ space-between：代表的是与交叉轴的两端对齐，轴线之间的距离平分。
+ space-around：代表的是轴线两侧的间隔相等，轴线之间的距离是轴线与边框之间距离的两倍
+ stretch：代表的是轴线占满整个交叉轴。

### 2.1.7 元素的属性 order

order代表的是元素的排列顺序，数值越小，排列越靠前。默认是0。可以取负值。

```scss
.item{
	order:0
}
```

### 2.1.8 元素的属性 flex-grow

.item {flex: 1;} == .item {    flex-grow: 1;    flex-shrink: 1;    flex-basis: 0%; }

flex-grow代表的是元素的放大的比例，默认是0。当设置为0时，即使存在剩余空间，也不放大。

```css
.item{
	flex-grow:<number>/*default 0 */
}
```

### 2.1.9 元素的属性 flex-shrink

flex-shrink属性代表的是元素的缩小比例，默认是1。即如果空间不足时，元素的比例将缩小。负值对该属性无效。

```css
.item{
	flex-shrink:<number>/*default 1*/
}
```

flex-grow和flex-shrink的相同点是当它们设置为0时，元素任性🉐️什么也不做。

### 2.1.10 元素的属性flex-basis

flex-basis可以设置固定值，可以设为跟`width`或`height`属性一样的值（比如350px），则项目将占据固定空间。

```css
.item {
  flex-basis: <length> | auto; /* default auto */
}
```

### 2.1.11 元素的属性flex

flex的属性是flex-grow、flex-shrink、flex-basis的简写，默认是0 1 auto表示的是元素不放大，空间不足时候会缩小，元素占据的主轴空间是元素本来的大小。

```css
.item{
	flex:<flex-grow> <flex-shrink> <flex-basis>
}
```

flex可以实现一行固定几个元素：

```scss
.item{
	flex: 0 0 33%;
}
```

### 2.1.12 元素的属性align-self

align-self可以覆盖align-items的属性。默认值是auto，表示的是继承父元素的align-items。

```scss
.item{
	align-self:auto|flex-start |flex-end|center|baseline|stretch;
}
```

## 2.2 css3的新特性

+ 新增了css选择器`:not(p) ` 选择每个非p的元素；`p:empty `选择每个没有任何子级的p元素（包括文本节点）；first-of-type选择其父元素的首个<p>元素；last-of-type选择其父元素的最后一个p元素。
+ 边框border：圆角
+ Linear-gradient 渐变`background:linear-gradient(direction,clolor-stop1,color-stop2)`;
+ 文本效果text-shadow；
+ transform:transform 属性向元素应用 2D 或 3D 转换；
+ 过渡transition；transition:all 2s,和hover一起使用；
+ **动画**
+ **flex 布局**
+ **多媒体查询** 定义两套css，当浏览器的尺寸变化时会采用不同的属性

  [参考](https://juejin.im/post/5a0c184c51882531926e4294#heading-5)

## 2.3 元素水平居中

```html
<div style="width: 1000px;
            height: 1000px;
            background: gray;">
	<div style="margin: 0 auto;
              background: red;
              width: 90px">
			son
	</div>
</div>
这种实现方式子元素必须要定宽。
```

```css
.parent{
	display:flex;
	justify-content:center
}
```

```html
<div style="width: 1000px;
            height: 1000px;
            background: gray;
            position: absolute;">
	<div style="position: absolute;
              background: red;
              left: 50%;
              transform: translate(-50%, 0);">
			son
	</div>
</div>
子元素定不定宽都可以
```

```html
<div style="width: 1000px;
			height: 1000px;
			background: gray;
			position: absolute;">
	<div stylebo="position: absolute;
              background: red;
              width: 100px;
              left: 50%;
              margin-left: -0.5*100px">
			son
	</div>
</div>
//子元素必须要定宽
```

## 2.4元素垂直居中

```css
.parent {
    height: 高度;
}
.son {
    line-height: 高度;
}
//行内元素
```

```html
.parent {
    display: flex;
    align-items: center;
}
```

```css
.son {
    position: absolute;
    top: 50%;
    height: 高度;
    margin-top: -0.5高度;
}
绝对定位定高
```

```css
.son {
    position: absolute;
    top: 50%;
    transform: translate( 0, -50%);
}
定不定高都可以
```

垂直水平居中兼容IE6

```html

<html>
    <head>
        <style>
        .box {
            width: 300px;
            height: 200px;
            background: green;
            position: absolute;;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            margin: auto;
        }
        </style>
    </head>
    <body>
        <div class="box">我是合子</div>
    </body>
</html>
 
```

## 2.5 BFC

BFC格式化上下文。是web页面中盒模型布局的css渲染模式，指一个独立的渲染区域或者是一个隔离的独立容器。它内部的元素怎么排列不会影响外部的元素的排列。

[参考](https://zhuanlan.zhihu.com/p/25321647)

触发BFC的条件：

+ body元素
+ 浮动元素，float不为none
+ 绝对定位:position(absolute、fixed)
+ display:inline-block、table-cells、flex
+ over-flow除了visible以外的值(hidden、auto、scroll)

BFC的应用

+ 同一个BFC下外边距会发生折叠，但是BFC不会与外部浮动盒子的外边距发生重叠。外部浮动的元素区域和BFC区域是泾渭分明的，不可能重叠。**操作浮动元素本身**

```css
<head>
	div{
	width:100px;
	height:100px;
	background:blue;
	margin:100px;
	}
</head>
<body>
	<div></div>
	<div></div>
</body>
```

<img src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_hd.png" alt="v2-0a9ca8952c83141250a2d9002e6d2047_hd" style="zoom:50%;" />

上下像个div间距应改为200px而不是100px，是一位传统的流式布局会取margin间距较大的那个值，这里就是100px，可以分别把两个div设置成BFC。

```html
<head>
  <style>
    .container {
    overflow: hidden;
		}
    p {
        width: 100px;
        height: 100px;
        background: lightblue;
        margin: 100px;
    }
  </style>
</head>
<body>
	<div class="container">
    <p></p>
  </div>
  <div class="container">
      <p></p>
  </div>
</body>
```

+ 清除浮动

浮动的元素会脱离文档流，**操作浮动元素的父元素**

```html
<div style="border 1px solid:#000000;overflow:hidden">
	<div style="width:100px;height:100px;background:red;float:left"></div>
</div>
```

<img src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_hd.png" alt="img" style="zoom:50%;" />

+ BFC可以阻止元素被浮动元素覆盖 （文本环绕）**操作浮动元素的兄弟元素**

```html
<div style="height:100px;width:100px;float:left;background-color: blue"></div>
    <div style="height:200px;width:200px;background:gray;overflow: hidden;"></div>
```

## 2.6 清除浮动

清除浮动一般不会动浮动元素的本身，只会动受浮动元素影响的元素。

### 2.6.1 利用clear清除浮动

textDiv元素告诉浏览器我的左边/两边不允许有浮动的元素存在。**操作浮动元素的兄弟元素**

```css
.textDiv {
    color: blue;
    border: 2px solid blue;
    clear: left;//clear:both
}
```

### 2.6.2 父元素结束标签之前插入清除浮动的块级元素

在有浮动元素的父元素的末尾插入一个没有内容的块级元素blankDiv：**插入新的块级元素**

```css
<div class="topDiv">
    <div class="textDiv">...</div>
    <div class="floatDiv">float left</div>
    <div class="blankDiv"></div>
</div>
.blankDiv {
    clear: both; // or left
}
```

这种方式和第一种方式的原理是一样的。

### 2.6.3 利用伪元素(clear fix) 

**插入新的块级元素**

在父级元素的最后加一个:after伪元素，通过清除伪元素的浮动达到：

```html
<div class="topDiv clearfix">
    <div class="textDiv">...</div>
    <div class="floatDiv">float left</div>
</div>
.clearfix:after {
    content: '.';
    height: 0;
    display: block;
    clear: both;
}
```

https://juejin.im/post/59e7190bf265da4307025d91

### 2.6.4 利用overflow:hidden/auto

在浮动元素的**父元素**加上overflow:hidden属性：

```css
<div class="topDiv">
    <div class="floatDiv">float left</div>
    <div class="textDiv">...</div>
</div>
.topDiv {
    width: 500px;
    padding: 4px;
    border: 2px solid black;
    // 区别在这里
    overflow: auto;
}
```

这是因为此时的父元素是一个BFC，BFC有三个特性：

1、BFC是一个独立渲染的区域，内部的元素无论怎么排列都不会影响外部元素的排列。

2、BFC元素的不会与外部的浮动元素的外边距重合，但是同一个BFC下上下两个div的外边距会重叠。

3、可以清除浮动，BFC在计算高度的时候会把内部的浮动元素的高度也计算在内，就是说BFC会防止塌陷。

4、可以阻止浮动元素覆盖，浮动的元素会覆盖传统布局的元素，可以把传统的元素设置成BFC，这样就不回覆盖传统的元素了。在HTML结构中，当构建一个BFC区域的元素旁边会有一个浮动的盒子时，BFC会首先尝试在浮动盒子的旁边渲染，当宽度不够时，就会在浮动元素的下方渲染。

## 2.7 box-sizing

box-sizing:border-box

表示的是IE盒子模型width=content+padding+border;

box-sizing:content-box

表示的是标准盒子模型，width=content;

W3C标准盒模型中**padding**、**border**所占的空间不在width、height范围内

## 2.8 三栏布局

​	[参考](https://zhuanlan.zhihu.com/p/25070186)

1、流体布局

## 2.9 硬件加速

css硬件加速
什么是硬件加速？硬件加速是将浏览器的渲染过程交给GPU处理，而不是使用自带的比较慢的渲染器。
硬件加速的原理：浏览器收到文档之后会将文档解析为DOM树，DOM树与CSS结合之后会形成浏览器构建的渲染树。每一个渲染元素会被分到一个图层中，而CSS transform会创建一个复合图层，这个符复合图层会被加载到GPU上形成渲染纹理，在GPU中的复合图层不会触发重绘。transform动画由GPU控制，支持硬件加速，并不需要软件方面的渲染。
触发硬件加速：
transform,opacity,filter
硬件加速并不会自动开启。需要浏览器这边来通知执行。

```javascript
.cube {
   -webkit-transform: translateZ(0);
   -moz-transform: translateZ(0);
   -ms-transform: translateZ(0);
   -o-transform: translateZ(0);
   transform: translateZ(0);
   /* Other transform properties here */
}
```

硬件加速的问题：内存问题，GPU加载了大量的渲染内存会被占用太大；GPU和CPU由于不同的渲染机制文字会有锯齿形状。

##  2.10标准模式和怪异模式

[参考](https://www.jianshu.com/p/dcab7cde8c04)

## 2.11 css animation

animation可以有6个属性

```css
animation: name duration timing-function delay iteration-count direction;
```

| 值                                                           | 描述                                     |
| :----------------------------------------------------------- | :--------------------------------------- |
| *[animation-name](https://www.w3school.com.cn/cssref/pr_animation-name.asp)* | 规定需要绑定到选择器的 keyframe 名称。。 |
| *[animation-duration](https://www.w3school.com.cn/cssref/pr_animation-duration.asp)* | 规定完成动画所花费的时间，以秒或毫秒计。 |
| *[animation-timing-function](https://www.w3school.com.cn/cssref/pr_animation-timing-function.asp)* | 规定动画的速度曲线。                     |
| *[animation-delay](https://www.w3school.com.cn/cssref/pr_animation-delay.asp)* | 规定在动画开始之前的延迟。               |
| *[animation-iteration-count](https://www.w3school.com.cn/cssref/pr_animation-iteration-count.asp)* | 规定动画应该播放的次数。                 |
| *[animation-direction](https://www.w3school.com.cn/cssref/pr_animation-direction.asp)* | 规定是否应该轮流反向播放动画。           |

keyframes规则创建动画的原理是将一套css样式逐渐变为另一套样式

```css
@keyframes mymove
{
from {top:0px;}
to {top:200px;}
}

@-moz-keyframes mymove /* Firefox */
{
from {top:0px;}
to {top:200px;}
}

@-webkit-keyframes mymove /* Safari 和 Chrome */
{
from {top:0px;}
to {top:200px;}
}

@-o-keyframes mymove /* Opera */
{
from {top:0px;}
to {top:200px;}
}
```

# 三、React

## 3.1 React diff算法

什么是虚拟dom？

Virtual DOM指的是用JS模拟的DOM结构，将dom的变化放在js层来做，Virtual DOM就是js对象。

为什么要vdom呢？

没有vdom的话我们每次操作dom结点时，不管数据是不是和原来一样，都会重新渲染，我们只希望改动数据变化的dom结点，dom重绘相当消耗浏览器的性能。因此我们采用虚拟dom的方式，将dom对比放在js层，减少不必要的重绘，提高效率。

react并没有说过比原生操作dom快，如果没有vdom，就是重置innerHTML。当一个大的列表所有的数据都变化的话，这样重置是比较合理的，但是假如之后一行数据变化了，重置整个innerHTML时，就是多了很多消耗资源的操作。

我们可以对比一下不用vdom的innerHTML和Vdom的重绘的性能消耗：

innerHTML：render html string O(template size) + 重新创建所有的DOM元素O(DOM size)

Vdom：render Virtual DOM + diff O(template size) + 必要的DOM更新**O(DOM change)**

render Virtual DOM + diff O显然比渲染html字符串要慢，但是这依然是js层面的计算，比起后面的dom操作来说依然是便宜了好多，可以看到innerHTML的总计算量不管是js计算还是DOM操作都是和整个界面相关的大小相关的，到那会死Vdom的计算里，只有js计算和界面大小相关，dom的操作设计和数据变化量相关的。

https://www.zhihu.com/question/31809713/answer/53544875

**为什么要了解diff这块内容呢？**

[什么是diff算法呢？](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.4.6927&rep=rep1&type=pdf)diff算法其实是1986年Myers提出的，用来解决最长公共序列问题(longest common sequence problem，LCS问题)。Dreact核心的两个内容就是virtual dom和diff算法。React diff作为Virtual DOM的加速器，其算法的改进优化是React界面渲染的基础，以及性能提高的保障。虽然开发中不需要知道其运行机制，但是理解之后有助于更好的理解React组件的生命周期，以及优化React程序。

**react diff和diff有什么不同呢？**

react diff是在diff算法上做了进一步人的优化，[传统的diff算法的时间复杂度是O(n^3)](https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf),而react diff算法的时间复杂度是O(n)，那么react diff究竟是怎么做到的呢？

其实，react diff是在传统的diff算法上做了三个假设条件:

\>1⃣️DOM 节点跨层级的移动操作特别少，可以忽略不计。

\>2⃣️拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。

\>3⃣️对于同一层级的一组子节点，它们可以通过唯一 id(key) 进行区分。

基于以上三个前提策略，React 分别对 ***\*tree diff、component diff 以及 element diff\**** 进行算法优化。

**tree diff **

基于假设一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。React对树做了层级控制，只会对某个节点的所有子节点进行比较，如下图，只会对同一颜色方框内的节点进行比较，而不会跨层级进行比较，传统的diff算法是跨层级对每个节点进行两两比较。如果一个父节点不存在了，那么该节点的子节点就不会再进一步比较了。只需要对树遍历一次就可以实现与DOM树的比较。

<!-- ![](/img/tree_diff1.png) -->

<img src="/img/tree_diff1.png" width="500" hegiht="313" align=center />



那如果有跨层级操作的dom节点怎么办呢？如下图A节点跨层级放到D节点的左子节点。React diff用趋近于‘暴力’的方式，并不是把A B C 直接拼接到 D 节点上，而是删除A B C 三个节点之后在 D 下面在创建的 A B C。此时，React diff 的执行情况：create A -> create B -> create C -> delete A。

<!-- ![](/img/tree_diff2.png) -->

<img src="/img/tree_diff2.png" width="500" hegiht="313" align=center />



**### component diff** 

\- 对于同一类型的组件，根据Virtual DOM是否变化也分两种，可以用shouldComponentUpdate()判断Virtual DOM是否发生了变化，若没有变化就不需要在进行diff，这样可以节省大量时间，若变化了，就对相关节点进行update

\- 对于非同一类的组件，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。



如下图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。

<img src="/img/component_diff.png" width="500" hegiht="313" align=center />

**### element diff**

这种情况是我们在开发中最常遇到的，所以详细分析一下这种情况。当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。

我们先来看没经过优化的diff算法在面对这种情况的时候是怎么操作的。

![](/img/element_diff1.png)

如上图，老集合中的节点是A、B、C、D，老集合中的节点是B、A、D、C，当传统的diff算法对新旧集合进行差异化对比时，当拿出新集合中的第一个节点B时，与旧集合中的第一个节点进行比较，发现B != A,此时，旧集合会先删除A节点，并创建B节点，后续会删除B、C、D节点创建A、D、C，这样下来我们发现会频繁的创建和删除dom节点，极大地降低页面的性能。这个时候我们想能不能通过移动现有的节点生成新的集合，而不是频繁的创建和删除节点呢？

<img src="/img/element_diff2.png" width="500" hegiht="313" align=center />

那么react diff 算法是怎么做的呢？优化后的react算法通过给每一个组件加一个key值，也就是给每一个组件加一个唯一性的标识。如下图，当react diff算法对新旧集合进行差异化对比时，发现新集合中的节点B在老集合中能找到，便对老集合中的B不做任何操作。

<!-- ![](/img/element_diff3.png =200x300) -->

<img src="/img/element_diff3.png" width="500" hegiht="313" align=center />

## 3.2 为什么要key？

官网上给的一句话是key帮助React准确识别哪些元素改变了，比如添加或者删除。

https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1

#### 为什么不用index当作key？

在列表渲染过程中，react通常会让加key，不加key时会有warning，最初为了消除warning，通常会把key设置为index，但是假如在这样的状况：我们改变列表的顺序或者是在表头增加列表项的时候，会导致重新创建列表项，特别是在表头新增列表项的时候会导致列表创建后面所有的项。因此更好的办法是使用列表项的id作为key值，这样既能保证key值的唯一性又能减少资源浪费。

主要是为了提升diff【同级比较】的效率。自己想一下自己要实现前后列表的diff，如果对列表的每一项增加一个key，即唯一索引，那就可以很清楚的知道两个列表谁少了谁没变。而如果不加key的话，就只能一个个对比了。

新增一个

```javascript
               Before                          After  
key=0 {checked:true,msg:'dinner'}  => {checked:false,msg:'TV'} 
key=1 {checked:false,msg:'jogging'}=> {checked:true,msg:'dinner'}
key=2 {checked:false, msg:'sleep'} => {checked:false,msg:'jogging'}
key=3                              => {checked:false,msg:'sleep'}
```

key设置为id

```java
                  Before                          After  
key=id0                              =>{checked:false,msg:'TV'} 
key=id1 {checked:true,msg:'dinner'}  =>{checked:true,msg:'dinner'}
key=id2 {checked:false,msg:'jogging'}=>{checked:true,msg:'jogging'}
key=id3 {checked:false, msg:'sleep'} =>{checked:false,msg:'sleep'}
```

参考：https://medium.com/@as790726/%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E8%A6%81%E7%B8%BD%E6%98%AF%E7%9B%B4%E6%8E%A5%E7%94%A8-array-%E7%9A%84-index-%E7%95%B6-react-component-%E7%9A%84-key-f8290f56b97c

**setState的机制是什么？**

[setsState机制](https://juejin.im/post/5bf1444cf265da614a3a1660)

setState是异步的，即执行完之后没有办法获取最新的state值，需要经过React对state的所有改变进行合并处理之后，才能计算出新的虚拟dom，再根据最新的dom去重新渲染真实的dom。

```javascript
class App extends Component{
  state={
    count:0
  }
  componentDidMount(){
    this.setState({count:this.state.count+1});
    console.log(this.state.count)
  }
  render(){
    ...
  }
}
```

那么怎么才能获取最新的修改后的state的值呢？可以通过回调函数去实现

```javascript
		...
    this.setState({count:this.state.count+1},()=>{
      console.log(this.state.count)//1
    })
		...
```

如果我们这样去做，

```java
	...
	this.setState({count:this.state.count+1})
	this.setState({count:this.state.count+1})
	...
```

最终输出的是1，因为在第一句执行完之后count还是0。

那么怎么才能实现结果是2呢？prevState可以拿到改变后的值

```
this.setState(prevState=>{count:prevState.count+1});
this.setState(prevState=>{count:prevState.count+1});
```

setState接受的是一个函数作为参数，函数的参数就是上一次的state。

```javascript
this.setState({count:this.state.count+1});
console.log("console",this.state.count);
this.setState({count:this.state.count+1},()={
	console.log("callback",this.state.count)
})
this.setState(prevState=>{  
	console.log("function",this.state.count)
	return{
	count:this.state.count+1;
	}
},()=>{
	console.log("last console",this.state.count)
})
```

输出顺序是：

```javascript
console 0
function 1
callback 2
last console 2
```

react会维护一个state的更新队列，每次调用setState时都会把修改推到这个队列，在最后进行合并处理，然后去执行回调。根据最终合并的结果再去更新虚拟dom，触发渲染。

**合成事件**

为了解决跨平台的问题，react自己封装了一套事件机制，代理了原生的事件，像在jsx中常见的onClick和onChang都是合成事件。

```javascript
class App extends Component {
  state = {
    count: 0
  };

  componentDidMount() {
    // 生命周期中调用
    this.setState({ count: this.state.count + 1 });
    console.log("lifecycle: " + this.state.count);//0
    setTimeout(() => {
      // setTimeout中调用
      this.setState({ count: this.state.count + 1 });
      console.log("setTimeout: " + this.state.count);
    }, 0);//2
    document.getElementById("div2").addEventListener("click", this.increment2);
  }

  increment = () => {
    // 合成事件中调用
    this.setState({ count: this.state.count + 1 });
    console.log("react event: " + this.state.count);
  };

  increment2 = () => {
    // 原生事件中调用
    this.setState({ count: this.state.count + 1 });
    console.log("dom event: " + this.state.count);
  };

  render() {
    return (
      <div className="App">
        <h2>couont: {this.state.count}</h2>
        <div id="div1" onClick={this.increment}>
          click me and count+1
        </div>
        <div id="div2">click me and count+1</div>
      </div>
    );
  }
}
```

上面的4种输出方式，合成的事件是increment，原生的是increment2，合成的事件setState之后不会马上改变count的值，原生的方法会马上改变count的值。

其中的原因是setState并不是真正意义上的异步，而只是模拟了异步的操作，React中会维护一个标志，isBatchingUpdates，判断是直接更新还是暂存在state队列中，setTimeout方法会直接去更新state中的count的值，合成事件是react的生命周期函数，所以会收到react的约束，isBatchingUpdates设置为true，从而走类似异步那套。

### 3.2.1 setState事件原理

**1、setState在合成事件中是异步的，但是在原生的事件中setState是同步的。**

2、最新的state中的count的值是可以通过setState中的回调函数拿到的。setState的异步并不是内部代码实现的，代码执行的是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在钩子函数和合成时间中是没有办法立马拿到state中的值的。

3、setState的批量更新也是建立在异步之上的，在原生事件和setTimeout中是不会批量更新的，在异步更新中的如果对一个值进行多次的setState，setState的批量更新策略会对其覆盖，最后一次的更新会覆盖前面的更新。

### 3.2.2 合成事件的原理

如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。

1. 当用户在为onClick添加函数时，React并没有将Click时间绑定在DOM上面。
2. 而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成）
3. 所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。

与原生事件的区别

React合成事件一套机制：React并不是将click事件直接绑定在dom上面，而是采用**事件冒泡**的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行和处理。

## 3.3 Hooks

React Hooks是react v16.8版本引入的全新的API，RN是在0.59版本引用的。

React Hooks的设计目的，就是加强版函数组件，完全不使用类，就能写出一个全功能的组件。

react hooks的意思是，组件尽量写成纯函数，需要外部功能和副作用，就用钩子把外部代码钩进来。

https://github.com/brickspert/blog/issues/26

https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d#heading-30

Q：为什么只能在函数最外层调用 Hook？为什么不要在循环、条件判断或者子函数中调用。

A：memoizedState 数组是按 hook定义的顺序来放置数据的，如果 hook 顺序变化，memoizedState 并不会感知到。

Q：自定义的 Hook 是如何影响使用它的函数组件的？

A：共享同一个 memoizedState，共享同一个顺序。

Q：“Capture Value” 特性是如何产生的？

A：每一次 ReRender 的时候，都是重新去执行函数组件了，对于之前已经执行过的函数组件，并不会做任何操作。

四个常用的钩子：**useState();useContext();useReducer();useEffect()**

**useState**

useState用于为函数组件引入状态。

```javascript
export default function button(){
	const [buttonText,setButtonText] = useState("click me");
  function handClick(){
    return setButtonText("been clicked!")
  }
  return <button onclick={handClick}>{buttonText}</button>
}
```

useState返回值是数组，数组的第一个值是当前状态的当前值，第二个值是更新状态的方法。

**useContext**

组件之间共享状态可以使用这个函数，比如现在有两个组件

```javascript
<div className="app">
	<Navbar/>
	<Message/>
</div>	
```

可以先使用React Context API，在组件外部建立一个Context。

```javascript
const AppContext = React.createContext({})
```

组件封装如下

```java
<AppContext.Provider value={{
	username:'superawesome'
}}>
	<div className='App'>
    <Navbar/>
    <Message/>
	</div>
</AppContext.Provider>	
```

Navbar组件：

```javascript
const Navbar = ()=>{
	const {username} = useContext(AppContext);
	return (
		<div className='navbar'>
			<p>{username}</p>
		</div>
	)
}
```

同样组件Message中也可以获取username

```html
const Message = ()=>{
	{username} = userContext(AppContext);
	return(
		<div classname='message'>
			<p>{username}</p>
		</div>
	)
}
```

## useReducer()：action 钩子

React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。

Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是`(state, action) => newState`。

`useReducers()`钩子用来引入 Reducer 功能。

> ```javascript
> const [state, dispatch] = useReducer(reducer, initialState);
> ```

上面是`useReducer()`的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的`dispatch`函数。

下面是一个计数器的例子。用于计算状态的 Reducer 函数如下。

> ```javascript
> const myReducer = (state, action) => {
> switch(action.type)  {
>  case('countUp'):
>    return  {
>      ...state,
>      count: state.count + 1
>    }
>  default:
>    return  state;
> }
> }
> ```

组件代码如下。

> ```javascript
> function App() {
> const [state, dispatch] = useReducer(myReducer, { count:   0 });
> return  (
>  <div className="App">
>    <button onClick={() => dispatch({ type: 'countUp' })}>
>      +1
>    </button>
>    <p>Count: {state.count}</p>
>  </div>
> );
> }
> ```

## useEffect()：副作用钩子

`useEffect()`用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在`componentDidMount`里面的代码，现在可以放在`useEffect()`。

1. 有两个参数 callback 和 dependencies 数组
2. 如果 dependencies 不存在，那么 callback 每次 render 都会执行
3. 如果 dependencies 存在，只有当它发生了变化， callback 才会执行

`useEffect()`的用法如下。

> ```javascript
> useEffect(()  =>  {
> // Async Action
> }, [dependencies])
> ```

上面用法中，`useEffect()`接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，`useEffect()`就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行`useEffect()`。

下面看一个例子。

> ```javascript
> const Person = ({ personId }) => {
> const [loading, setLoading] = useState(true);
> const [person, setPerson] = useState({});
> 
> useEffect(() => {
>  setLoading(true); 
>  fetch(`https://swapi.co/api/people/${personId}/`)
>    .then(response => response.json())
>    .then(data => {
>      setPerson(data);
>      setLoading(false);
>    });
> }, [personId])
> 
> if (loading === true) {
>  return <p>Loading ...</p>
> }
> 
> return <div>
>  <p>You're viewing: {person.name}</p>
>  <p>Height: {person.height}</p>
>  <p>Mass: {person.mass}</p>
> </div>
> }
> ```

上面代码中，每当组件参数`personId`发生变化，`useEffect()`就会执行。组件第一次渲染时，`useEffect()`也会执行。****

## 创建自己的 Hooks

上例的 Hooks 代码还可以封装起来，变成一个自定义的 Hook，便于共享。

> ```javascript
> const usePerson = (personId) => {
> const [loading, setLoading] = useState(true);
> const [person, setPerson] = useState({});
> useEffect(() => {
>  setLoading(true);
>  fetch(`https://swapi.co/api/people/${personId}/`)
>    .then(response => response.json())
>    .then(data => {
>      setPerson(data);
>      setLoading(false);
>    });
> }, [personId]);  
> return [loading, person];
> };
> ```

上面代码中，`usePerson()`就是一个自定义的 Hook。

Person 组件就改用这个新的钩子，引入封装的逻辑。

> ```javascript
> const Person = ({ personId }) => {
> const [loading, person] = usePerson(personId);
> 
> if (loading === true) {
>  return <p>Loading ...</p>;
> }
> 
> return (
>  <div>
>    <p>You're viewing: {person.name}</p>
>    <p>Height: {person.height}</p>
>    <p>Mass: {person.mass}</p>
>  </div>
> );
> };
> ```

# 三、vue/node

相同点
1 都支持服务器端渲染
2 都有Virtual DOM（虚拟dom）,组件化开发,都有’props’的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据,都实现webComponent规范
3 数据驱动视图
4 都有支持native的方案,React的React native,Vue的weex
5 构建工具
React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。都有管理状态，React有redux,Vue有自己的Vuex（自适应vue，量身定做）

区别
设计思想
react
1 函数式思想，all in js ,jsx语法，js操控css
2 单项数据流
3 setState重新渲染
4 每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，如果为true继续渲染、false不渲染，但Vue将此视为默认的优化。

vue
1 响应式思想，也就是基于数据可变的。把html、js、css、组合到一起，也可以通过标签引擎组合到一个页面中
2 双向绑定，每一个属性都需要建立watch监听（页面不用，涉及到组件更新的话需要）
3 Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树

性能
react ----大型项目
优化需要手动去做，状态可控
vue ------中小型项目
状态改变需要watch监听，数据量太大的话会卡顿

扩展性
react
1 类式写法api少，更容易结合ts
2 可以通过高阶组件来扩展
vue
1 声明式写法，结合ts比较复杂
2 需要通过mixin方式来扩展

React刚开始也有mixin的写法，通过React.createClass的api，不过现在很少用了。
Vue也不是不能实现高阶组件，只是特别麻烦，因为Vue对与组件的option做了各种处理，想实现高阶组件就要知道每一个option是怎么处理的，然后正确的设置。具体有多复杂，可以参考下面的文章。
http://hcysun.me/2018/01/05/探索Vue高阶组件

## 3.1 node是单线程为什么能够实现高并发？

https://zhuanlan.zhihu.com/p/61807318

node的执行过程是js代码首先通过v8引擎编译，node调取api加入到事件循环中，node中有任务队列和执行栈，node中的单线程指的是主线程是单线程。

1. 每个Node.js进程只有一个主线程在执行程序代码，形成一个**执行栈**（**execution context stack**)。
2. 主线程之外，还维护了一个"**事件队列**"（Event queue）。当用户的网络请求或者其它的异步操作到来时，node都会把它放到Event Queue之中，此时并不会立即执行它，代码也不会被阻塞，继续往下走，直到主线程代码执行完毕。
3. 主线程代码执行完毕完成后，然后通过Event Loop，也就是**事件循环机制**，开始到Event Queue的开头取出第一个事件，从线程池中分配一个线程去执行这个事件，接下来继续取出第二个事件，再从**线程池**中分配一个线程去执行，然后第三个，第四个。主线程不断的检查事件队列中是否有未执行的事件，直到事件队列中所有事件都执行完了，此后每当有新的事件加入到事件队列中，都会通知主线程按顺序取出交EventLoop处理。当有事件执行完毕后，会通知主线程，主线程执行回调，线程归还给线程池。
4. 主线程不断重复上面的第三步。

## 3.2 node 错误处理

https://blog.csdn.net/cauyahui/article/details/96272498

### 3.2.1 try/catch 接口

异步代码下使用try{}catch结构捕获处理效果如何呢？

```
try {  
  setTimeout(()=>{
    throw new Error('错误信息');
  })
} catch (e) {
  console.error('error is:', e.message);
}
```

### 3.2.2 process的uncaughtException事件

那异步错误该怎么处理呢？首先换个思维，因为异常并不是事先准备好的，不能控制其到底在哪儿发生，所以站更高的角度，如监听应用进程的错误异常，从而捕获不能预料的错误异常，保证应用不至于奔溃调。

```
process.on('uncaughtException', (e)=>{  
  console.error('process error is:', e.message);
  process.exit(1);  restartServer(); // 重启服务
});
```

### 3.2.3 domain方式

process方式虽然可以捕获任何类型的异常，但是process太过笨重，除了记录下错误信息，其他地方不适合使用，domain这个也可以处理任何类型异常的模块，显然是一个不错的选择。

```js
let domain = require('domain')
let d = domain.create()
d.on('error', function (e) {
    /*处理异常*/
    console.log(e.message)
})
d.run(asyncError)
d.run(syncError)
```

## 3.3 node服务进程守护是如何做的

https://www.cnblogs.com/xumengxuan/p/12131547.html

在多进程守护这块，node也推出了`cluster模块`，用来解决多核CPU的利用率问题。同时cluster中也提供了exit事件来监听子进程的退出。

## 3.4 cluster模块

https://blog.csdn.net/u012060033/article/details/102766342

**`对于多核CPU的计算机来说，这样做效率很低，因为只有一个核在运行，其他核都在闲置`**。`cluster模块`就是为了解决这个问题而提出的。

Node.js默认单进程运行，对于32位系统最高可以使用512MB内存，对于64位最高可以使用1GB内存。对于多核CPU的计算机来说，这样做效率很低，因为只有一个核在运行，其他核都在闲置。cluster模块就是为了解决这个问题而提出的。

cluster模块允许设立一个主进程和若干个worker进程，由主进程监控和协调worker进程的运行。
worker之间采用进程间通信交换消息，cluster模块内置一个负载均衡器，采用Round-robin算法协调各个worker进程之间的负载。
运行时，所有新建立的链接都由主进程完成，然后主进程再把TCP连接分配给指定的worker进程。

## 3.5 pm2

**pm2 是一个带有负载均衡功能的Node应用的进程管理器。可以把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载。**

pm2的主要特性

1、内建负载均衡（使用Node cluster 集群模块）
 2、后台运行
 3、0秒停机重载
 4、具有Ubuntu和CentOS 的启动脚本
 5、停止不稳定的进程（避免无限循环）
 6、控制台检测
 7、提供 HTTP API
 8、远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )

## 3.6 node中的cluster模块采用了哪种集群模式？

node中的cluster采用的是多个进程去监听同一个端口，这样做的好处是进程间的通信相对简单、减少了端口的资源浪费。

**为什么可以多个进程可以监听同一个端口呢？**

因为这个端口并不是被所有的进程全部监听，仅受到Master进程的监听。Master通过cluster.fork()方法创建Worker，Master进程创建一个Socket并绑定监听到该目标端口，通过与子进程之间建立IPC通道之后，通过调用子进程的send方法，将Socket（链接句柄）传递过去。



# 四 webpack

webpack是一种模块化的解决方案，它可以分析你的项目结构将代码打包成适合浏览器加载的模块。他的公作方式是将项目当成一个整体，各一个主文件，webpack将从这个文件中找到你的项目中的所有的依赖文件，使用loaders处理它们，并在最后打包成一个或者多个浏览器可识别的js文件。

Loaders ：通过使用不同的loader，webpack调用外部的脚本或者是工具，实现对不同格式的文件的处理，比如说拆分scss为css，或者把es6/es7代码转换成现代浏览器兼容的js代码，或者把jsx代码转换成js代码。loader一般有test（处理文件的扩展名的正则表达式）和loader（loader名字）属性；常见的loader style-loader/css-loader/post-css/babel-loader

Plugins：是用来扩展webpack的功能的，他和loader完全是不同的东西，loader是在项目打包的过程中处理scss/jsx/less文件的，插件plugins并不会直接处理这些文件，他是直接对整个构建过程起作用。

HtmlWebpackPlugin:可以动态的引入js,因为每次打包后的js hash值可能不一样，它可以根据具体的hash值

HotModuleReplacementPlugin：模块热替换插件

SplitChunksPlugin ,代码分割插件

# 五 网络

## 5.1 CDN

CDN的工作原理就是将您源站的资源缓存到位于全球各地的CDN节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、缓解源站压力，保证用户访问资源的速度和体验
链接：https://www.jianshu.com/p/1dae6e1680ff

## 5.2 Https的工作原理及与http的区别

Https 工作原理：

HTTPS是在HTTP上简历SSL加密层，并对传输数据进行加密，是HTTP协议的安全版，HTTPS的主要作用是1）对数据进行加密并建立一个安全信息通道保证数据传输的安全；2）对网站真实身份进行验证

HTTPS的协议主要功能是依赖于TLS/SSL协议，TLS/SSL的主要功能依赖于三类基本的算法：散列函数、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据进行加密，基于散列函数验证信息的完整性。

HTTPS的请求过程主要是：

1、前端发起一个HTTPS请求，与服务器建立SSL连接

2、服务器收到客户端请求之后会返回公钥证书返回给客户端

3、Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。

4、Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server

5、Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。

6、Server使用对称密钥加密“明文内容A”，发送给Client。

7、Client使用对称密钥解密响应的密文，得到“明文内容A”。

8、Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。

HTTPS优化总结易记版：

1、HSTS重定向技术：将http自动转换为https，减少301重定向

2、TLS握手优化：在TLS握手完成前客户端就提前向服务器发送数据

3、会话标识符：服务器记录下与某客户端的会话ID，下次连接客户端发ID过来就可以直接用之前的私钥交流了

4、OSCP Stapling：服务器将带有 CA 机构签名的 OCSP 响应在握手时发给客户端，省的客户端再去CA查询

5、完全前向加密PFS：使用更牛逼复杂的秘钥算法

**Keep-Alive模式**

我们都知道HTTP是基于TCP的，每一个HTTP请求都需要进行三步握手。如果一个页面对某一个域名有多个请求，就会进行频繁的建立连接和断开连接。所以HTTP 1.0中出现了`Connection: keep-alive`，用于建立长连接，即我们所说的Keep-Alive模式。下图是普通模式和长连接模式的请求对比： 

HTTP/1.0中默认使用Connection: close。在HTTP/1.1中已经默认使用Connection: keep-alive。

通过对比可以看出，Keep-Alive模式更加高效，因为避免了连接建立和释放的开销。但是，如果一个连接是不会断开的，那么多个请求之间如何进行区分呢？也就是说浏览器是如何知道当前请求已经完成了呢？为了解决这个问题，HTTP对header中又添加了一个`Content-Length`字段。

Content-Length

`Content-Length`表示实体内容的长度。浏览器通过这个字段来判断当前请求的数据是否已经全部接收。 
所以，当浏览器请求的是一个静态资源时，即服务器能明确知道返回内容的长度时，可以设置`Content-Length`来控制请求的结束。但当服务器并不知道请求结果的长度时，如一个动态的页面或者数据，`Content-Length`就无法解决上面的问题，这个时候就需要用到`Transfer-Encoding`字段。

Transfer-Encoding

`Transfer-Encoding`是指传输编码，还有一个类似的字段叫做：`Content-Encoding`。两者的区别是`Content-Encoding`用于对实体内容的压缩编码，比如`Content-Encoding: gzip`；`Transfer-Encoding`则改变了报文的格式，比如上面的问题中，当服务端无法知道实体内容的长度时，就可以通过指定`Transfer-Encoding: chunked`来告知浏览器当前的编码是将数据分成一块一块传递的。当然, 还可以指定`Transfer-Encoding: gzip, chunked`表明实体内容不仅是gzip压缩的，还是分块传递的。最后，当浏览器接收到一个长度为0的chunked时， 知道当前请求内容已全部接收。

```
HTTPS和HTTP的区别：
https协议需要到ca申请证书，一般免费证书很少，需要交费。
http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。
http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。
http的连接很简单,是无状态的。
HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全。
```

## 5.3 DNS原理

dns基于UDP 35端口

具体过程如下：
①用户主机上运行着DNS的客户端，就是我们的PC机或者手机客户端运行着DNS客户端了
②浏览器将接收到的url中抽取出域名字段，就是访问的主机名，比如 并将这个主机名传送给DNS应用的客户端
③DNS客户机端向DNS服务器端发送一份查询报文，报文中包含着要访问的主机名字段（中间包括一些列缓存查询以及分布式DNS集群的工作）
④该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址
⑤一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP连接

**使用分布式集群的工作方式**

从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询

# 五、常见的面试题

## 4.1 将"www.baidu.com"变成"com.baidu.com"

方法1:字符串的自有方法

```javascript
var s = "www.baidu.com";
console.log(s.split(".").reverse().join("."));
```

方法2:利用正则对象regexp

```javascript
var s = "www.baidu.com";
console.log(s.replace(/(\w+).(\w+).(\w+)/,"$3.$2.$1"));
```

## 4.2 隔一段时间打印数组中的一个元素

 加入有一个数组[1,2,3,4,5]；每隔1秒打印一个元素。

```javascript
var arr = [1,2,3,4,5];
var i = 0;
var timer = setInterval(()=>{
  console.log(i);
  i++;
  if(i>arr.length-1){
    clearInterval(timer);
  }
},1000)
```

## 4.3字符串改成驼峰

```javascript
var str = "get-element-by-id";
var newStr="";
var arr = str.split("-");
console.log("arr",arr);
for(var i= 0;i<arr.length;i++){
    if(i==0){
        newStr +=arr[i]
    }else{
        newStr+=arr[i].substr(0,1).toLocaleUpperCase()+arr[i].substr(1,arr[i].length-1);
        //newStr+=arr[]
    }
    
}
console.log(newStr);
//substr一般取完值后一般是拼接在一起的
```

## 4.4 对象属性去重

```javascript
	var users=[
    {
      id:1,name:"a"
    },{
       id:2,name:"a"
    },{
       id:3,name:"b"
    },{
       id:4,name:"v"
    }]
Array.prototype.unique = function () {
    var res;
    this.map(item => {
        this[item.id -1] = item.name
    })
    // ES6里新添加了两个很好用的东西，set和Array.from
    // set是一种新的数据结构，它可以接收一个数组或者是类数组对象，自动去重其中的重复项目。
    res=new Set(this);
    console.log("new Set对象",res)
    // 但是这里大家可以看到，set返回的是一个对象，但是我们想要的是数组啊。
    // 这回，就该轮到Array.from出场了，它的作用，就是可以把类数组对象、可迭代对象转化为数组。
    res=Array.from(new Set(this));
    //console.log(  res)//es6 数组去重
    return  res//es6 数组去重
}
console.log(users.unique());
```

## 4.5 知识点清单

[前端缓存](https://zhuanlan.zhihu.com/p/44789005?utm_source=qq&utm_medium=social&utm_oi=815669732077355008)  看完以后收获颇多，把一直以来缓存位置的疑惑也给解决了

[Jsonp详解](https://blog.csdn.net/hansexploration/article/details/80314948) 终于知道Jsonp的真正运作原理了

[跨域详解](https://juejin.im/post/5c23993de51d457b8c1f4ee1) 各种跨域详解，用promise封装Jsonp实现方式，让我眼前一亮

[js常见的内存泄漏及解决方法总汇](http://www.fly63.com/article/detial/225?type=2) 不错的总结

[JS手写代码](https://juejin.im/post/5c9c3989e51d454e3a3902b6) 其他都挺好的，感觉防抖节流还见过更好的版本

[前端安全知识](https://juejin.im/post/59dc2b7a6fb9a0451869ae3a) 终于对XSS,CSRF有个清晰的认识了


作者：三耳朵
链接：https://juejin.im/post/5ca463ae6fb9a05e6b44c6fd
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 4.6 批量请求数据

题目：请实现如下的函数，可以批量请求数据，所有的URL地址在 urls 参数中，同时可以通过 max 参数控制请求的并发数，当所有的请求结束之后，需要执行 callback 回调函数。发请求的函数可以直接使用 fetch 即可。

```javascript
const fetch = require('node-fetch')
    //let bodyElement = document.body
    let urls = [
  'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2580986389,1527418707&fm=27&gp=0.jpg',
      'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1995874357,4132437942&fm=27&gp=0.jpg',
      'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2640393967,721831803&fm=27&gp=0.jpg',
      'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1548525155,1032715394&fm=27&gp=0.jpg',
      'https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2434600655,2612296260&fm=27&gp=0.jpg',
      'https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=2160840192,133594931&fm=27&gp=0.jpg'
    ]
    let max = 4
    let callback = () => {
      console.log('所有请求完成了')
    }
    // 定义一个分组函数 已 max 为最大个数存储在一个对象中
    function sendRequest(urls, limit , callback) {
    function _send (urls) {
        return fetch(urls.shift())
            .finally(() => {
            	console.log("ztf")
                if(urls.length) {
                    return _send(urls)
                }
            })
    }
    let asyncList = [];
    while(limit--) {
        asyncList.push(_send(urls));
    }
    return Promise.all(asyncList).then(callback);
}

sendRequest(urls, max, function() {
    console.log('finish')
});
```



```javascript
function sendRequest(urls, limit , callback) {
    function _send (urls) {
        return new Promise((resolve, reject) => {
        	const url = urls.shift();
        	if(url){
        		setTimeout(()=>{
                    console.log(`当前发送：${url}`);
                    resolve(url);       
            }, 10)
        	}   
        })
        .finally(() => {
            if(urls.length > 0) {
                return _send(urls)
            }
        })
    }
    let asyncList = [];
    while(limit--) {
        asyncList.push(_send(urls));
    }
    return Promise.all(asyncList).then(callback);
}

sendRequest(urls, max, function() {
    console.log('all urls sended!')
});
```

## 4.7千分位

正则实现

```javascript
function split(value) {  
    let str = value.toString();
    let reg = /(\d{1,3})(?=(\d{3})+$)/g;
    return str.replace(reg, "$1,")
}
```

非正则实现

```javascript
function split(val){
    let a = val.toString().split('').reverse(),
        arr = [];
    for(let i = 0; i < a.length; i += 3){
        arr.push(a.slice(i,i+3).reverse().join(''))
    }
    return arr.reverse().join(',');
}
```

```javascript
function split3(value) {  
    return value.toLocaleString()
}
```

## 4.8 promise.all and promise.race

```javascript
// Promise.all
Promise._all = function(ite) {
    return new Promise(function(resolve, reject){
        let count = 0, rel = [];
        for(let i in ite){
            let p = ite[i];
            // if (typeof p === 'object' && typeof p.then === 'function') {
            // } else {
            // }
            p.then(function(res){
                rel[i] = res;
                count++;
                if(count == ite.length) resolve(rel)
            })
        }
    })
}
// Promise.race
Promise._race = function(ite){
    return new Promise(function(resolve, reject){
        let count = 0;
        for(let i in ite){
            let p = ite[i];
            p.then(function(res){
                if(count == 0) {
                    resolve([res])
                }
            })
        }
    })
}


let p1 = new Promise(function(resolve,reject){
    setTimeout(resolve, 400, 'a')
})
let p2 = new Promise(function(resolve,reject){
    setTimeout(resolve, 100, 'b')
})
let p3 = new Promise(function(resolve,reject){
    setTimeout(resolve, 80, 'c')
})

Promise._all([p1,p2,p3]).then(function(rel){
    console.log(rel)
})

Promise._race([p1,p2,p3]).then(function(rel){
    console.log(rel)
})
```

## 4.9 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

```javascript
let str2 = '{}[{}([{()}])][]';
function test2(str) {
    str = str.trim();
    function calc(str){
        let preLength = str.length;

        str = str.split('()').join('');
        str = str.split('[]').join('');
        str = str.split('{}').join('');

        if(str.length != preLength){
            return calc(str)
        } else {
            return str.length == 0
        }
    }
    return calc(str);
}
console.log(test2(str2))
```

## 4.10实现一个bind函数

```javascript
Function.prototype._bind = function(ctx){
    let self = this;
    return function(){
        self.call(ctx, ...arguments)
    }
}
function a(m,n,o){
    console.log(this.name + ' ' + m + ' ' + n + ' ' + o);
}
var b = {
    name: 'kong'
};

a._bind(b)(7,8,9)
```

## 4.11 将两个有序数组合并为一个数组。请不要使用concat以及sort方法。

```
function merge(left, right) {
  var result = [],
    il = 0,
    ir = 0;

  while (il < left.length && ir < right.length) {
    if (left[il] < right[ir]) {
      result.push(left[il++]);
    } else {
      result.push(right[ir++]);
    }
  }
  result.push(left[il] ? left[il] : right[ir]);
  return result;
}
var left = [1, 4, 7];
var right = [2, 5];
console.log(merge(left, right))
```

## 4,12 终止fetch请求

超时设置

```javascript
let timeoutPromise = (timeout) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve("我是 timeoutPromise，已经完成了");
        }, timeout);
    });
}
let requestPromise = (url) => {
    return fetch(url);
};
Promise.race([timeoutPromise(1000), requestPromise("https://www.baidu.com")])
    .then(resp => {
        console.log(resp);
    })
    .catch(error => {
        console.log(error);
    });
```

取消请求

```javascript
timeoutResp=new Response("timeout", { status: 504, statusText: "timeout " })
  successResp=new Response("ok", { status: 200, statusText: "ok " })
//AbortController 用于手动终止一个或多个DOM请求，通过该对象的AbortSignal注入的Fetch的请求中。所以需要完	美实现timeout功能加上这个就对了

//ahutor:herbert qq:464884492
let controller = new AbortController();
let signal = controller.signal;

let timeoutPromise = (timeout) => {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve(new Response("timeout", { status: 504, statusText: "timeout " }));
            controller.abort();
        }, timeout);
    });
}
let requestPromise = (url) => {
    return fetch(url, {
        signal: signal
    });
};
Promise.race([timeoutPromise(1000), requestPromise("https://www.baidu.com")])
    .then(resp => {
        console.log(resp);
    })
    .catch(error => {
        console.log(error);
    });
```

## 4.13 从一个数组中找出 N 个数，其和为 M 的所有可能

```javascript
function search(arr, count, sum) {
  var len = arr.length, res = [];
  for (var i = 0; i < Math.pow(2, len); i++) {
	if (n(i) == count) {
	  var s = 0, temp = [];
	  for (var j = 0; j < len; j++) {
		if (i & 1 << (len - 1 -j)) {
		  s += arr[j]
		  temp.push(arr[j])
		}
	  }
	  if (s == sum) {
		res.push(temp)
	  }
	}
  }
  return res;
}

function n(i) {
  var count = 0;
  while( i ) {
   if(i & 1){
    ++count;
   }
   i >>= 1;
  }
  return count;
}

console.log(search([1,2,3,4],2,5))
// => [[2,3],[1,4]]
```

https://juejin.im/post/5c81fee66fb9a049b82b4128

### 4.14  先序遍历-中序遍历-后序遍历


https://segmentfault.com/a/1190000004620352

### 4.15 判空函数

```javascript
function isEmpty(a){
            if (a === "") return true; //检验空字符串
            if (a === "null") return true; //检验字符串类型的null
            if (a === "undefined") return true; //检验字符串类型的 undefined
            if (!a && a !== 0 && a !=="") return true; //检验 undefined 和 null           
            if (Array.prototype.isPrototypeOf(a) && a.length === 0 ) return true; //检验空数组
            if (Object.prototype.isPrototypeOf(a) && Object.keys(a).length === 0 ) return true;  //检验空对象
            return false;
        }
```

1.先创建该视图的viewmanager类，我们以LottieViewManager类为例，这个类继承自SimpleViewmanager,
必需的方法为getName和createViewInstance两个方法，一个是返回创建的view名字，一个是创建view实例。
导出视图的属性设置器：使用@ReactProp（或@ReactPropGroup）注解。
2.注册ViewManger。创建自己的ReactPackage的子类实现LottiePackage,封装的原生UI组件放在createViewManagers里,然后将LottiePackage添加到ReactActivity中

3.实现对应的JS模块。UIManager.dispatchViewManagerCommand把调用命令分发到Native端对应的组件类型的ViewManager，再通过ViewManager调用View组件实例的对应方法。
4.使用封装的原生UI
https://www.jianshu.com/p/f26d994ea765

在深入了解Handler机制原理之前，我们应该明确在Handler机制中几个重要类的职责。

- Handler：负责发送处理消息
- MessageQueue：消息队列，负责存储消息
- Message: 具体发送的消息
- Looper: 负责循环取出消息给Handler处理
- ThreadLocal: 用于线程间的数据隔离，在每个线程中存放各自对应的Looper

#### 3. Handler机制原理

> - 每个Handler都会关联一个消息队列，消息队列又是封装在Looper对象中，而每个Looper又会关联一个线程。这样Handler、消息队列、线程三者就关联上了。
> - Handler是一个消息处理器，将消息发送给消息队列，然后再由对应的线程从消息队列中逐个取出，并执行。
> - 默认情况下，消息队列只有一个，也就是主线程的消息队列，该消息队列通过Looper.prepareMainLooper()方法创建，最后执行Looper.loop()来循环启动消息。

Handler机制的原理，大致可以总结为：在子线程中Handler将消息发送到MessageQueue中，然后Looper不断的从MessageQueue中读取消息，并调用Handler的dispatchMessage发送消息，最后再Handler来处理消息。