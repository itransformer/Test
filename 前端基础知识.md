

# 一、js

### 1、this的指向&箭头函数

**this不是定义的时候决定的，它是函数的当前执行环境决定的，或者说是this指向的是最终调用它的对象（当调用它的对象包含多个对象时，尽管函数是被最外层的对象调用的，this指向的是函数的上一级对象）。**

Exp:

```javascript
var message = "outside"
function f1(){
  var message = "inside";
  console.log(this.message);//outside
  console.log(this);//Window
}
```

由于f1是在全局对象Window中执行的，所以此时的this指向的是Window对象。

Exp：

```javascript
var message = "outside";
var obj = {
  messgae : "inside";
  f1:function(){
    console.log(this.message);
  }
} 
obj.f1();//inside
```

这里函数f1是在obj中执行的，所以此时的this指向的是对象obj。上面的window对象是js中的全局对象，我们创建的变量实际上就是给window对象添加属性。

**当调用它的对象包含多个对象时，尽管函数是被最外层的对象调用的，this指向的是函数的上一级对象**

这句话是是什么意思呢？

exp:

```javascript
var o = {
  message:"outside",
		a:{
      message:"middle",
      b:{
        message:"inside",
        fn:function(){
          console.log(this.message);
        }
      }
    }
}
o.a.b.fn();//inside
```

此时调用函数fn的对象是o，但是，输出的却是对象b中的属性值，这就是因为this会指向它的上一级对象。

再来一个例子验证一下结论

exp:

```javascript
var o = {
  message:"outside",
		a:{
      message:"middle",
      b:{
        message:"inside",
        fn:function(){
          console.log(this.message);
        }
      }
    }
}
var f = o.a.b.fn;
f();//undefined
```

此时的fn()相当于window.fn()，this指向的是window对象。

参考：https://www.cnblogs.com/pssp/p/5216085.html

箭头函数中的this是在定义的时候决定的，箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this，且无论怎么改变调用方式都不会改变this的指向。

exp:

```javascript
var message = "outside";
var obj = {
  message:"inside",
  fn:()=>{
    console.log(this.message);
  }
}
obj.fn();//outside
```

此时的箭头函数的作用域链的上一层就是window对象，所以此时的this指向的是全局对象window。

exp:

```javascript
var message = "window";
var obj = {
  message : "obj";
  fn: function(){
    return ()=>{
      console.log(this.message);
    }
  }
}
obj.fn()();//obj
```

```javascript
var message = "window";
var obj = {
  message : "obj",
  fn: function(){
    return function(){
      console.log(this.message);
    }
  }
}
obj.fn()();//window
```

这里return箭头函数的时候返回的是当前对象obj，此时的fn是一个闭包，函数fn内是一个完整的作用域，此时的作用域链的上一层就是obj，所以this指向obj。

当return的是匿名函数时，因为匿名函数是在全局作用域中执行的，所以此时的this指向的是window。

这里我们总结出来一个结论：

**当有外部函数包裹箭头函数时，this指向的是当前的对象；**

**当没有外部函数包裹箭头函数时，this指向的是window；**

### 2、promise和setTimeout的执行顺序

```javascript
var p = Promise.resolve(1);
console.log(2);
setTimeout(()=>{
	console.log(3);
},0)
p.then((res)=>{
	console.log(res);
})
console.log(4);//打印结果：2 4 1 3
```

promise会在当前事件循环的末尾执行，setTimeout是在下一次事件循环中执行。

### 3、事件循环 宏任务/微任务

浏览器在执行任务时，同步任务会进入主线程，即执行栈，异步任务会进入事件队列Event Queue。主线程内的任务执行完毕，会去事件队列中调取异步任务推入主线程执行，这个过程不断重复就是事件循环（Event Loop）。

<img src="/Users/zhangtengfei9/Library/Application Support/typora-user-images/image-20191111143452056.png" alt="image-20191111143452056" style="zoom:50%;" />

在事件循环中，一个 完整的循环称为tick，关键步骤：

1、在当前tick中选择宏任务执行，这里的宏任务一般是script（整体代码）；

2、检查任务队列中是否有微任务，如果存在则执行，直至执行完所有的微任务；

3、更新render；

4、重复以上步骤。

<img src="/Users/zhangtengfei9/Library/Application Support/typora-user-images/image-20191111143531796.png" alt="image-20191111143531796" style="zoom:67%;" />

宏任务：script整体代码、setTimeout、setInterval、I/O、UI交互事件、setImmediate（Node.js执行环境）

微任务：Promise、process.nextTick（node.js执行环境）	

Exp

```javascript
console.log("script start");
setTimeout(function(){
  console.log("setTimeout");
},0);
Promise.resolve().then(function(){
  console.log("promise then1");
}).then(function(){
  console.log("promise then2");
});
console.log("end");
//script start 
//end
//promise then1
//promise then2
//setTimeout
```

比较复杂的Exp

```javascript
async function async1(){
  console.log("async1 start");
  await async2();//此时，执行完async2之后，后面的语句暂停执行，跳出括号执行外面的同步任务。外部同步代码执行完毕，接着回到async1()内部, 由于async2()其实是返回一个Promise, await async2()相当于获取它的值，其实就相当于这段代码Promise.resolve(undefined).then((undefined) => {}),所以.then会被推入微任务队列, 所以现在微任务队列会有两个任务。接下来处理微任务队列，打印console.log( 'promise2' )，后面一个.then不会有任何打印，但是会执行
  console.log("async1 end");
}
async function async2(){
  console.log("async2")
}
console.log("script start")
setTimeout(function(){
  console.log("setTimeout")
},0)
async1();
new Promise(function(resolve){
  console.log("promise1")
	resolve();
}).then(function(){//第一次循环时，此时将这句加入到任务队列。
  console.log("promise2")
})
console.log("script end")
//script start
//async1 start
//async 2
//promise1
//script end
//promise2
//async1 end 
//setTimeout
```

### 4、强缓存和协商缓存

**浏览器缓存分为强缓存和协商缓存，强缓存就是不经过浏览器而强制浏览器使用本地的缓存数据，与强缓存相关的两个字段是expires和cache-control；协商缓存就是由服务器确定缓存资源是否可用，客户端后和服务器要通过某种标识来进行通信，从而让服务器判断是否可以缓存访问。**

![image-20191112172604980](/Users/zhangtengfei9/Library/Application Support/typora-user-images/image-20191112172604980.png)

##### 强缓存

**Expires**:这是http1.0的规范，它的值是一个GMT格式的时间字符串，也就是过期的截止时间，如果请求的时间在这之前，那么本地的缓存是有效的，否则就是发送请求到服务器获取资源。所以这种方式有一个明显的缺点，由于失效的时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。如果同时出现`Cache-Control:max-age`和`Expires`，那么`max-age`优先级更高。

**Cache-control:max-age=number**，这是http1.1时定义的字段属性，单位是秒。它是一个相对时间，资源第一次请求的时间和cache-control设定的时间计算出一个资源过期时间，再拿这个时间和当前的请求的时间做对比，如果在请求的时间在这个是假之前就是命中缓存。

+ no-cache：不使用本地缓存。
+ no-store：不强制缓存也不协商缓存。
+ public：浏览器和代理服务器都可以缓存（对于private和public，前端可以认为一样，不用深究）。
+ private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。

##### 协商缓存

这个主要涉及到两组header字段：`Etag`和`If-None-Match`、`Last-Modified`和`If-Modified-Since`。

Etag/If-None-Match是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。Etag保证每一个资源是唯一的，资源的变化会导致Etag的变化。是在第一次请求返回时的资源最后修改时间，当第二次再次请求资源时，Etag以If-None-Match的形式传给服务器，服务器根据If-None-Match的值是否改变来判断是否命中缓存。与last-Modified不同的是，当服务器返回304时，由于Etag是重新生成的，此时response会返回Etag，即使Etag和之前的没有变化。

Last-Modified/If-Modified-Since是在第一次请求返回时的资源最后修改时间，当第二次再次请求资源时，last-Modified以If-Modified-Since的形式传给服务器，服务器根据最后修改时间判断是否命中缓存。如果资源没有变化则返回304，此时不会返回资源内容，也不会返回last-Modified。如果有变化返回200,返回资源。

|              | **获取资源形式** | **状态码**          | **发送请求到服务器**                       |
| ------------ | ---------------- | ------------------- | ------------------------------------------ |
| **强缓存**   | 从缓存取         | 200（from cache）   | 否，直接从缓存取                           |
| **协商缓存** | 从缓存取         | 304（not modified） | 是，正如其名，通过服务器来告知缓存是否可用 |

#####为什么要Etag

上面的描述中通过last-modified就可以判断是否使用缓存的资源，为什么还需要Etag呢？这里的Etag是http1.1中对上个版本做的优化，原因如下：

+ 一些资源可能会更改，但是其内容可能没有什么变化，此时如果仅仅使用last-modified判断的话就会重新get服务器资源请求，而通过Etag判断的话就不会重新请求资源。

+ If-modified-Since是秒为单位的，如果某个资源在一秒内修改了多次，此时根据这个字段是没有办法判断更新的。

+ 某些服务器不能精确的得到文件的最后修改时间。

  If-None-Match和If-modified-Since是可以同时使用的，服务器收到这两个字段时**ETag优先级更高**，当Etag（`If-None-Match`）一致时，继续比对`Last-Modified`（`If-Modified-Since`），最后才决定是否返回304。

### 5、闭包

##### 什么是闭包？

闭包就是有权访问另一个函数作用域中变量的函数，也就是说闭包可以让你从内部函数访问外部函数的作用域。

```javascript
function outer(){
  var a = "999";
  var inner = function(){
    console.log(a);
  }
  return inner;
}
var result = outer();
result();
```

此时的inner函数就是一个闭包。

正常情况下outer函数执行完之后，其作用域会被销毁，垃圾回收器会释放那段内存空间。

总结：某个函数在定义函数的作用域之外的地方被调用，闭包可以使该函数访问定义时的词法作用域。

Exp:

```javascript
for(var i = 0;i<10;i++){
  setTimeout(function(){
    console.log(i);
  },1000)
}
```

上面的例子会输出10个10，而不是1，2，3，4......10；setTimeout里的匿名函数执行的时候i已经是10了，所以会输出10次10。怎么解决这个问题呢？就是在for循环每次在执行的时候保存当时的i的值，这就需要一个私有作用域，在这个私有的作用域中保存当时的i的值。

```javascript
for(var i = 0;i<10;i++){
  (function(){
	  var j = i;
    setTimeout(function(){
      console.log(j);
    },1000)
  })()
}
```

#####面试题：exp

```javascript
function fn(n,o){
  console.log(o);
  return {
    fn:function(m){
      return fn (m,n);
    }
  };
}
var a = fn(0);a.fn(1);a.fn(2);a.fn(3);//undefined 0 0 0
var b = fn(0).fn(1).fn(2).fn(3);//undefined 0 1 2
var c = fn(0).fn(1);c.fn(2);c.fn(3);//undefided 0 1 1
```

1、a

fn(0)执行时，输出o时undefined，返回值是{function fn(m){return fn(m,0)}}对象，此时的第二层fn函数就是一个闭包，n = 0被保存到闭包中;

a.fn(1)当该函数return时，执行fn(1,0)，输出0；

a.fn(2)当该函数return时，执行fn(2,0)，输出0；

a.fn(2)当该函数return时，执行fn(3,0)，输出0；

2、b

fn(0)执行时，输出o时undefined，返回值是{function fn(m){return fn(m,0)}}，此时的第二层fn函数就是一个闭包，n = 0被保存到闭包中;

fn(0).fn(1)执行时，return语句会执行fn(1,0)，输出0，此时n=1被保存在闭包函数中，此时返回{function fn(m){return fn(m,1)}}对象；

fn(0).fn(1).fn(2)执行时，就是执行fn(2,1)，输出1，此时n=2被保存在闭包函数中，此时返回{function fn(m){return fn(m,2)}}对象；

fn(0).fn(1).fn(2).fn(3)执行时，就是执行fn(3,2)，输出2，此时n=3被保存在闭包函数中，此时返回{function fn(m){return fn(m,3)}}对象；

3、c

c就是对象{function fn(m){return fn(m,1}}，此时n=1被保存在闭包函数中，此时依次输出undefined，0；

c.fn(2)执行时，就是fn(2,1)执行，输出1，此时n=2保存在闭包中，返回值是{function fn(m){return fn(m,2)}}对象；

c.fn(3)执行时，就是执行fn(3,1)，输出1，此时n=3被保存在闭包中，返回值是{function fn(m){return fn(m,3)}}对象；

参考：https://www.cnblogs.com/xxcanghai/p/4991870.html

### 6、打开浏览器有多少进程

### 7、浏览器的缓存方法有哪些？优先级是怎样的？

浏览器的缓存方式主要有**Cookie、LocalStorage、SessionStorage、Serviece Worker**

Cookie：一般指网站为了辨别用户身份存储在终端上的数据，它一般是通过http请求中在头部一起发送到服务器。一般大小是4k。

LocalStorage：是html5的一种新的本地缓存方式，一般用来存储ajax返回的数据，加快页面下一次的打开速度。

它会一直保存在内存中，直到用户清除浏览器为止，容量大小一般是5M。

SessionStorage：特性同LocalStorage，页面关闭时，sessionStorage回清空。

|      特性      |                            Cookie                            |                        localStorage                         |                   sessionStorage                   |      |
| :------------: | :----------------------------------------------------------: | :---------------------------------------------------------: | :------------------------------------------------: | ---- |
|  数据的生命期  | 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 |                  除非被清除，否则永久保存                   |    仅在当前会话下有效，关闭页面或浏览器后被清除    |      |
|  存放数据大小  |                            4K左右                            |                          一般为5MB                          |                     一般为5MB                      |      |
| 与服务器端通信 | 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 |     仅在客户端（即浏览器）中保存，不参与和服务器的通信      | 仅在客户端（即浏览器）中保存，不参与和服务器的通信 |      |
|     易用性     |          需要程序员自己封装，源生的Cookie接口不友好          | 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 |                                                    |      |

### 8、状态值304？为什么要减少https的请求？

#####304

当浏览器GET请求的时候，如果有If-Modified-Since，则会与当前服务器上相关资源最后一次修改时间进行对比，如果相同则返回304（资源可访问，但没修改），否则加载最新数据，浏览器再缓存起来。这样减少网络数据传输和服务器压力。

为什么要减少https请求？

因为每次请求request都会带数据，请求头里这些数据的传输是需要时间的，当请求越多的时候，传输的所花的时间也就越多。

其次，http的链接需要域名解析-开启tcp连接-发送请求-等待-下载资源-文件解析，这个过程的每个阶段都需要消耗时间。

参考：https://blog.csdn.net/chenchun91/article/details/52207008

https比http慢是因为https多了一个ssl握手。

https和http都是建立在tcp协议之上，http经过三次握手之后就发送数据了。客户端首先发送SYN包，服务器收到之后发送SYN+ACK包给客户端，最后客户端再发送ACK包给服务器，接下来就发送内容了。

1. HTTP耗时 = TCP握手 
2. HTTPs耗时 = TCP握手 + SSL握手

#####http2与http1的区别

http2.0（超文本传输协议），主要是基于SPDY协议（是Google开发的基于TCP的应用层协议，用以最小化网络延迟，提高网络速度，优化用户的网络体验）。

Http2 采用二进制格式而非文本格式

Http2是多路复用技术，而非有序阻塞的，只需要一个连接就可以实现并行

Hppt2支持对header数据的压缩

Http2让服务器可以将响应主动推送到客户端

### 9、事件冒泡与事件捕获

事件冒泡：当鼠标点击某个dom结点时（被触发这个点击事件的元素叫做事件源），浏览器会从事件源=》根节点进行从内到外传播。

事件捕获：根节点=〉事件源，从外到内传播。

dom标准事件流的触发的先后顺序为；先捕获再冒泡。即当触发dom事件时，会先从外到内进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。

addEventListener的第三个参数

addEventListener方法有三个参数，第一个参数是需要绑定的事件类型，第二个参数是触发事件后要执行的函数，第三个参数是布尔类型。

```javascript
element.addEventListener(event,function,useCapture);//capture捕获
```

useCapture默认是false，表示在事件冒泡阶段调用事件处理函数；如果参数是true，表示在事件捕获阶段调用处理函数。

#####事件冒泡：

```javascript
<body>
  <div id="parent">
    父元素
    <div id="child">
      子元素
    </div>
  </div>
  <script type="text/javascript">
    var parent = document.getElementById("parent");
    var child = document.getElementById("child");

    document.body.addEventListener("click",function(e){
      console.log("click-body");
    },false);

    parent.addEventListener("click",function(e){
      console.log("click-parent");
    },false);

    child.addEventListener("click",function(e){
      console.log("click-child");
    },false);
  </script>
</body>
```

第三个参数是false，会在事件冒泡阶段处理函数，因此会（从内到外）从事件源=》根节点。上述代码执行的结果如下：

![image-20191127201622387](/Users/zhangtengfei9/Library/Application Support/typora-user-images/image-20191127201622387.png)

#####阻止事件冒泡

如果点击元素不想传递到父元素，可以用event.stopPropagation()。

```javascript
child.addEventListener("click",function(e)){
     console.log("click-child");
			e.stopPropagation();
},false);
```

##### 事件捕获：

```javascript
var parent = document.getElementById("parent");
var child = document.getElementById("child");

document.body.addEventListener("click",function(e){
  console.log("click-body");
  },false);

parent.addEventListener("click",function(e){
  console.log("click-parent---事件传播");
},false);
    　　　　 
　　　　 //新增事件捕获事件代码
parent.addEventListener("click",function(e){
  console.log("click-parent--事件捕获");
},true);

child.addEventListener("click",function(e){
  console.log("click-child");
},false);
```

执行结果：

![image-20191128141446428](/Users/zhangtengfei9/Library/Application Support/typora-user-images/image-20191128141446428.png)

##### 事件委托

一般来讲就是会把一个或者一组元素的事件委托到它的父层或者更外层元素上，而真正绑定的是最外层的元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制触发到它的外层元素的绑定事件上，然后在外层元素上执行函数。

```html
<ul id="list">
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
  ......
  <li>item n</li>
</ul>
```

事件委托的好处：

1、减少内存消耗 提高性能

每一个事件函数都是需要内存消耗的，只需要在外层元素上添加一个事件的话内存消耗会更少。

2、动态绑定事件

使用事件委托可以自动绑定动态添加的元素。比如上述的例子，我们给每个列表项都绑定事件，在很多时间我们需要通过用户操作去动态的添加或者删掉列表项的元素，那么在每一次添加元素的时候都要新绑定事件，删除元素的时候需要删去元素的绑定事件；如果用了事件委托就不会有这种麻烦了。因为事件是绑定在父元素中的， 和目标元素的增减是没有关系的。

```javascript
<ul id="list">
  <li className="class-1">item 1</li>
  <li>item 2</li>
  <li className="class-1">item 3</li>
  ......
  <li>item n</li>
</ul>
<script>
document.getElementByid("list").addEventListener("click",function(e){
    var event = e || window.event;
    var target = event.target;
    if(target.matches("class-1")){
      console.log(target);
    }
  })
</script>
```

### 10、输入url浏览器经过哪些过程？

参考

https://juejin.im/entry/57f10284da2f60004f5f2e5e

https://juejin.im/post/5ad4094e6fb9a028d7011069

主要过程：

**1、域名解析**

**2、TCP连接**

**3、发送HTTP请求**

**4、服务器处理请求并返回报文**

**5、浏览器解析渲染页面**

**6、连接结束**

这个问题是不是说得越详细越好呢？说的很详细面试官也可能会抓一个细的点而自己又不擅长的点问，其实可以说的细致一点 ，但是面试官如果抓到细致的点问可能了解一些就行，估计不要求多么的深刻的理解。细致的过程就是：

1、输入URL

2、域名解析，浏览器查找域名对用的IP地址，这是DNS的查找过程，首先会先向本地本地服务器请求，这时候本地服务器先去读取它的缓存，如果缓存中有此记录就返回缓存中的，如果没有就继续向域名服务器请求  

3、tcp连接

4、发送http请求

5、服务器处理请求

6、服务器返回一个http响应

7、浏览器解析渲染页面



**1、域名解析**

**2、建立tcp连接**

为什么要三次握手？

这是因为防止已经失效的请求报文突然又传到服务器，浪费资源，因而产生错误。

其中主要是**三次握手**

第一次握手：客户端发送syn包到服务器，进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到客户端发来的SYN包，同时自己发送一个SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包之后，想服务器发送确认包ACK，此包发送完之后客户端和服务器端进入ESTABLISHED状态，完成三次握手。

三次握手结束后客户端和服务器才开始传输数据。

**四次挥手**

客户端发送FIN包，用来关闭客户端到服务器的传输

服务器收到这个FIN包，并发送一个ACK包

服务器关闭数据传输，发送一个FIN包给客户端

客户端发回ACK包确认。

TCP与UDP的区别都在网络的传输层。

**TCP与UDP的区别？**

### 11、Generation

```javascript
function* gen(x){
	y = yield x+1;
	return y;
}
var g = gen(1);
g.next() // { value: 3, done: false }
g.next() // { value: undefined, done: true }
```

一个函数，参数是generation函数，怎么执行完所有generation中的yield呢？

```javascript
function run(f){
	for(let v of f()){
		console.log(v);
	}
};
function* g(){
	yield 1;
	yield 2;
	yield 3;
}
run(g)
```

### 12、获取页面中的所有img

```javascript
document.getElementsBytagName("img")
```

### 13、事件格式化为2小时前，一分钟前

```javascript
//JavaScript函数：
var minute = 1000 * 60;
var hour = minute * 60;
var day = hour * 24;
var halfamonth = day * 15;
var month = day * 30;
function getDateDiff(dateTimeStamp){
var now = new Date().getTime();
var diffValue = now - dateTimeStamp;
if(diffValue < 0){
 //若日期不符则弹出窗口告之
 //alert("结束日期不能小于开始日期！");
 }
var monthC =diffValue/month;
var weekC =diffValue/(7*day);
var dayC =diffValue/day;
var hourC =diffValue/hour;
var minC =diffValue/minute;
if(monthC>=1){
 result="发表于" + parseInt(monthC) + "个月前";
 }
 else if(weekC>=1){
 result="发表于" + parseInt(weekC) + "周前";
 }
 else if(dayC>=1){
 result="发表于"+ parseInt(dayC) +"天前";
 }
 else if(hourC>=1){
 result="发表于"+ parseInt(hourC) +"个小时前";
 }
 else if(minC>=1){
 result="发表于"+ parseInt(minC) +"分钟前";
 }else
 result="刚刚发表";
return result;
}
```

### 14、微信小程序原理

微信小程序是基于web规范

**小程序在三端的运行环境是不同的：**

ios：javaScriptCore

android：旧版本是x5,新版本是V8

在开发工具上：NW.js，node-webkit

**双线程模型：**小程序的渲染层和逻辑层分别是由2个线程管理，渲染层使用webview进行渲染，逻辑层使用jscore线程运行js脚本。

**通信问题：**小程序的逻辑层和渲染层的通信是由native(微信客户端)做中转的，逻辑层发送网络请求也经由native转发。

**视图层<->微信**

Ios:wkwebview提供的messageHandlers

Android:往 WebView 的 window 对象注入一个原生方法，最终会封装成 WeiXinJSBridge 这样一个兼容层，主要提供了调用（invoke）和监听（on）这两种方法。

**逻辑层<->微信**

iOS 平台可以往 JavaScripCore 框架注入一个全局的原生方法，而安卓方面则是跟渲染层一致的。

### 15、回流和重绘

参考1:https://segmentfault.com/a/1190000017329980

参考2:https://juejin.im/post/5a9923e9518825558251c96a

**回流一定会导致重绘。**

回流：浏览器构建渲染树，将可见的dom节点以及样式对应起来，可是我们还需要计算他们在设备视口中的确切位置和大小，这个计算的过程就是回流。

重绘：把每个节点转换为屏幕上实际的像素，这个阶段就是重绘节点。

什么情况下会导致回流呢？

- 页面首次渲染

- 浏览器窗口大小发生改变

- 元素尺寸或位置发生改变

- 元素内容变化（文字数量或图片大小等等）

- 元素字体大小变化

- 添加或者删除**可见**的`DOM`元素

- 激活`CSS`伪类（例如：`:hover`）

- 查询某些属性或调用某些方法

  什么情况下会导致重绘呢？

  当页面中元素样式的改变并**不影响它在文档流中的位置**时（例如：`color`、`background-color`、`visibility`等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘

  

浏览器的优化机制：

每次回流都会导致额外的计算造成计算消耗，因此浏览器会通过队列化批量进行回流过程。浏览器将要回流的操作加入到一个队列中，直到过一段时间或者达到一个阈值时，才清空队列。但是当你获取布局信息的时候会强制队列刷新，比如：

- offsetTop、offsetLeft、offsetWidth、offsetHeight
- scrollTop、scrollLeft、scrollWidth、scrollHeight
- clientTop、clientLeft、clientWidth、clientHeight
- getComputedStyle()
- getBoundingClientRect
- 具体可以访问这个网站：[https://gist.github.com/pauli...](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)

***怎样减少回流和冲毁重绘？***

1、避免使用table布局

2、将动画应用到position为absolute或者fixed的元素上。

3、避免过多的使用内联样式

4、使用css3硬件加速（GPU加速）

5、避免频繁的操作样式，最好一次性重写style属性

6、可以先设置元素的display:none，操作结束后再把他显示出来，因为在display属性为none的元素上进行dom的操作不会引起回流和重绘。

7、css3硬件加速，可以让transform、opacity、filters这些动画不会重绘，

重点

- 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘
- 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

#### css3硬件加速的坑

- 如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。
- 在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。

#### webpack

什么是webpack，weboack可以看作是模块打包机，

### 16、async await

https://segmentfault.com/a/1190000007535316

### 17、webpack

webpack是一种模块化的解决方案，它可以分析你的项目结构将代码打包成适合浏览器加载的模块。他的公作方式是将项目当成一个整体，各一个主文件，webpack将从这个文件中找到你的项目中的所有的依赖文件，使用loaders处理它们，并在最后打包成一个或者多个浏览器可识别的js文件。

Loaders ：通过使用不同的loader，webpack调用外部的脚本或者是工具，实现对不同格式的文件的处理，比如说拆分scss为css，或者把es6/es7代码转换成现代浏览器兼容的js代码，或者把jsx代码转换成js代码。loader一般有test（处理文件的扩展名的正则表达式）和loader（loader名字）属性；常见的loader style-loader/css-loader/post-css/babel-loader

Plugins：是用来扩展webpack的功能的，他和loader完全是不同的东西，loader是在项目打包的过程中处理scss/jsx/less文件的，插件plugins并不会直接处理这些文件，他是直接对整个构建过程起作用。

HtmlWebpackPlugin:可以动态的引入js,因为每次打包后的js hash值可能不一样，它可以根据具体的hash值

HotModuleReplacementPlugin：模块热替换插件

SplitChunksPlugin ,代码分割插件

### 观察者模式

观察者模式又称为发布订阅模式，是行为模式的一种，它定义了一对多的依赖关系，让多个观察者对象监听一个主题对象，这个主题对象的状态发生变化时，对通知所有的观察者对象，是他们自己自动更新。

包括抽象观察者和具体观察者，抽象主题和具体主题

使用场景：关联行为场景/事件多级出发场景/

优点：解除耦合，让耦合的双方都依赖抽象，从而使得各自的变换不会影响另一边。

缺点：使用观察者模式应该考虑开发效率和y n



### 13、git merge 和 rebase

merge 是合并的意思，rebase是复位基底的意思。
现在我们有这样的两个分支,test和master，提交如下：

```bash
     D---E test
    /
A---B---C---F master
```

在master执行`git merge test`然后会得到如下结果：

```bash
     D--------E
    /          \
A---B---C---F---G    test , master
```

在master执行`git rebase test`,然后得到如下结果：

```bash
 A---C---D---E---C `---F` test , master
```

可以看到merge操作会生成一个新的节点，之前提交分开显示。而rebase操作不会生成新的节点，是将两个分支融合成一个线性的操作。

通过上面可以看到，想要更好的提交树，使用rebase操作会更好一点，这样可以线性的看到每一次提交，并且没有增加提交节点。
 在操作中。merge操作遇到冲突时候，当前merge不能继续下去。手动修改冲突内容后，add 修改，commit 就可以了
 而rebase操作的话，会中断rebase，同时会提示去解决冲突。解决冲突后，将修改add后执行git rebase -continue继续操作，或者git rebase -skip忽略冲突。

###  14、let const var

var的话会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针

let的话，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错

const的话，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性

### 15、实现bind方法

https://juejin.im/post/5b00f146f265da0b7e0c8a54

```
let obj = {
  ll: 'seve'
};

Function.prototype.bind = function(that) {
  var self = this;
  return function() {
    return self.apply(that, arguments);
  };
};
let func0 = function(a, b, c) {
  console.log(this.ll);
  console.log([a, b, c]);
}.bind(obj, 1, 2);

func0(3); // seve
```

#### es6 进阶版

es6 提供了结构运算符，可以很方便的利用其功能实现 bind

```
Function.prototype.bind = function(that, ...argv) {
  if (typeof this !== 'function') {
    throw new TypeError(`${this} is not callable`);
  }
  // 保存原函数
  let self = this;
  // 获取bind后函数传入的参数
  return function(...argu) {
    return self.apply(that, [...argv, ...argu]);
  };
};
let func1 = function(a, b, c) {
  console.log(this.ll);
  console.log([a, b, c]);
}.bind(obj, 1, 2);

func1(3); // seve
// [ 1, 2, 3 ]
复制代码
```

es6 版实现很简单对吧，但是面试官说我们的运行环境是 es5，这时你心中窃喜，bable 大法好，但是你可千万不要说有 babel，因为面试官的意图不太可能是问你 es6 如何转换成 es5，而是考察你其他知识点，比如下面的类数组如何转换为真正的数组

#### es5 进阶版

```
Function.prototype.bind = function() {
  if (typeof this !== 'function') {
    throw new TypeError(`${this} is not callable`);
  }
  var self = this;
  var slice = [].slice;
  // 模拟es6的解构效果
  var that = arguments[0];
  var argv = slice.call(arguments, 1);
  return function() {
    // slice.call(arguments, 0)将类数组转换为数组
    return self.apply(that, argv.concat(slice.call(arguments, 0)));
  };
};
let func2 = function(a, b, c) {
  console.log(this.ll);
  console.log([a, b, c]);
}.bind(obj, 1, 2);

func2(3); // seve
// [ 1, 2, 3 ]
复制代码
```

当然，写到这里，对于绝大部分面试，这份代码都是一份不错的答案，但是为了给面试官留下更好的印象，我们需要上终极版 实现完整的bind函数，这样还可以跟面试官吹一波

#### 终极版

为了当使用new操作符时，bind后的函数不丢失this。我们需要把bind前的函数的原型挂载到bind后函数的原型上

但是为了修改bind后函数的原型而对bind前的原型不产生影响，都是对象惹的祸。。。直接赋值只是赋值对象在堆中的地址 所以需要把原型继承给bind后的函数，而不是直接赋值，我有在一些地方看到说Object.crate可以实现同样的效果，有兴趣的可以了解一下，但是我自己试了下，发现效果并不好，new 操作时this指向错了(可能是我使用姿势错了)

**通过直接赋值的效果**

```
Function.prototype.bind = function(that, ...argv) {
  if (typeof this !== 'function') {
    throw new TypeError(`${this} is not callable`);
  }
  // 保存原函数
  let self = this;
  let func = function() {};
  // 获取bind后函数传入的参数
  let bindfunc = function(...arguments) {
    return self.apply(this instanceof func ? this : that, [...argv, ...arguments]);
  };
  // 把this原型上的东西挂载到func原型上面
  // func.prototype = self.prototype;
  // 为了避免func影响到this，通过new 操作符进行复制原型上面的东西
  bindfunc.prototype = self.prototype;

  return bindfunc;
};

function bar() {
  console.log(this.ll);
  console.log([...arguments]);
}
let func3 = bar.bind(null);

func3.prototype.value = 1;

console.log(bar.prototype.value) // 1    可以看到bind后的原型对bind前的原型产生的同样的影响
复制代码
```

**通过继承赋值的效果**

```
Function.prototype.bind = function(that, ...argv) {
  if (typeof this !== 'function') {
    throw new TypeError(`${this} is not callable`);
  }
  // 保存原函数
  let self = this;
  let func = function() {};
  // 获取bind后函数传入的参数
  let bindfunc = function(...argu) {
    return self.apply(this instanceof func ? this : that, [...argv, ...argu]);
  };
  // 把this原型上的东西挂载到func原型上面
  func.prototype = self.prototype;
  // 为了避免func影响到this，通过new 操作符进行复制原型上面的东西
  bindfunc.prototype = new func();

  return bindfunc;
};

function bar() {
  console.log(this.ll);
  console.log([...arguments]);
}
let func3 = bar.bind(null);

func3.prototype.value = 1;

console.log(bar.prototype.value) // undefined   可以看到bind后的原型对bind前的原型不产生影响

func3(5);     // seve
              // [ 5 ]
new func3(5); // undefined
              // [ 5 ]
```

### 17、防抖与节流

**## 什么是防抖和节流**

先抛出防抖与节流的概念：

***\*防抖(debounce):在任务频繁触发的情况下，只有任务触发的时间间隔超过指定间隔的时候，任务才会执行。\****（在时间间隔内不论你你点击多少次，我根本就不予理会。）

如下图所示，红线表示触发事件，触发事件的频率是0.5s，设置防抖的时间间隔是1s，见如此时每隔0.5s触发一次事件，在10s内不会事件一次都不会成功触发。

<img src="/img/debounce-1.jpg"  />灰色表示的是事件触发的情况，因为始终没法等1s就被再次触发了，所以最终没有一次事件是成功的。

***\*节流(throttle)：指定时间间隔内只会执行一次任务。\****(每隔特定的时间就执行一次，不管你在这个特定时间内触发事件多少次，我只执行一次)

如下图所示，红线表示触发事件，绿线表示成功触发该事件，触发事件的频率是0.5s，设置节流的时间间隔是1s，可以看到每隔1s，事件会成功触发一次。

<img src="/img/debounce-2.jpg"  />

**## 防抖与节流的实现**

不知怎地，防抖和节流让我不由自主的想起雪姨敲门的情景，下面就拿雪姨敲门举例。

**### 防抖：**

原理：防抖的原理是设置一个定时器，并给定时器设置一个定时的时间值，当频繁的触发请求函数时，下一次执行的函数会在执行时把上次延迟还没执行的函数清空，所以，只要不停的在定时器的默认时间值内触发函数，就会请求函数就会一直被清除，直到最后一次成功触发。

对于函数防抖，有以下几种应用场景：

1、给按钮加函数防抖防止表单多次提交。

2、对于输入框连续输入进行AJAX验证时，用函数防抖能有效减少请求次数。

3、判断scroll是否滑到底部，滚动事件+函数防抖

```
function _debounce(fn,wait){

​    var timer = null;

​    return function(){

​        clearTimeout(timer)

​        timer = setTimeout(()=>{

​            fn()

​        },wait)

​    }

}

function out(){
  console.log(Math.random())
   //console.log(document.getElementById('input').value)

}
setInterval(_debounce(out,1000),500) //雪姨每隔500ms就敲一次门，但是主人公心里想：你就敲吧，只要不大于1000ms，我就不开门！

//setInterval(_debounce(out,1000),1001) // 敲不开门没有办法了,雪姨决定作出让步,1001s敲一次，终于，门开了！此后，每隔1001ms会开一次门

function clearfun(){
  console.log('ddd')
  document.getElementById('input').value='';
}
```

实际的应用场景举例：

```javascript
document.getElementById('input').oninput = _debounce(out,500)
function _debounce(fn,wait){
​    var timer = null;
​    return function(){
​        clearTimeout(timer)
​        timer = setTimeout(()=>{
​            fn()
​        },wait)
​    }
}

//ajax请求函数

function ajax(){
   console.log(document.getElementById('input').value)
}
```

### 节流：

原理：节流就是判断当前这次的函数触发时间和上次的函数触发时间的时间差是否大于规定的延迟时间值，若大于就成功触发函数。

对于函数节流，有如下几个场景：

1、游戏中的刷新率

2、DOM元素拖拽

3、Canvas画笔功能

时间戳版：

```javascript
function throttle(fn, gapTime) {

  let _lastTime = null;

  return function () {

​    let _nowTime = + new Date()

​    if (_nowTime - _lastTime > gapTime || !_lastTime) {

​      fn();

​      _lastTime = _nowTime

​    }

  }

}



function out(){

  console.log(Math.random())

   //console.log(document.getElementById('input').value)

}
```

setInterval(throttle(out,1000),10) // 雪姨还是暴脾气，每隔10ms敲一次门，门里面的人也改变了规则，无论你怎么敲门，我每隔1000ms给你开一次门

\```

定时器版:

```javascript
function throttle(func, wait) {

​    let timeout;

​    return function() {

​        let context = this;

​        let args = arguments;

​        if (!timeout) {

​            timeout = setTimeout(() => {

​                timeout = null;

​                func.apply(context, args)

​            }, wait)

​        }



​    }

}
```

时间戳版和定时器版的节流函数的区别:时间戳版的函数触发是在时间段内开始的时候，而定时器版的函数触发是在时间段内结束的时候。

将时间戳版和定时器版的节流函数结合起来，实现双剑合璧版的节流函数。

双剑合璧版:

```javascript
/**

 \* @desc 函数节流

 \* @param func 函数

 \* @param wait 延迟执行毫秒数

 \* @param type 1 表时间戳版，2 表定时器版

 */

function throttle(func, wait ,type) {
​    if(type===1){
​        let previous = 0;
​    }else if(type===2){
​        let timeout;
​    }
​    return function() {
​        let context = this;
​        let args = arguments;
​        if(type===1){
​            let now = Date.now();
​            if (now - previous > wait) {
​                func.apply(context, args);
​                previous = now;
​            }
​        }else if(type===2){
​            if (!timeout) {
​                timeout = setTimeout(() => {
​                    timeout = null;
​                    func.apply(context, args)
​                }, wait)
​            }
​        }
​    }
}
```

### 18、深拷贝浅拷贝

**js中数据的存储**

先总结一下js中数据的类型和数据的存储方式；

**  数据类型**

基本类型：undefined、null、boolean、number、string、Symbol</br>

引用类型：Object

**数据存储方式**

js中数据有两种存储方式：***栈存储和堆存储***。其中基本数据类型主要放在栈中，引用类型主要放在堆中。

***栈内存***：基本类型在内存中占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。

***堆内存***：引用类型的地址是固定大小的，存储在栈内存中，引用类型的值大小是不固定的，所以，值是存在堆内存中的。

**浅拷贝**

浅拷贝MDN并没有给出明确的定义。

根据自己的理解，***浅拷贝（浅复制）主要拷贝的数据类型是对象，浅拷贝只拷贝对象的第一层的属性，如果拷贝的对象有子对象，那么浅拷贝并不会递归的拷贝其子对象的属性。***

```javascript
var obj1={
​    id:1,
​    arr:[1,2]
}

function copy(obj){
​    var o={}
​    for (var prop in obj){
​        if(obj.hasOwnProperty){
​            o[prop]=obj[prop]
​        }
​    }
​    return o;
}

obj2=copy(obj1);

obj2.id=2;
obj2.arr[0]=0

obj1.id//1
obj2.id//2

obj1.arr//[0,2]
obj2.arr//[0,2]
```

**深拷贝**

***它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。***

**利用递归实现深拷贝(多层对象)**

```java
var obj1={
​    id:1,
​    arr:[1,2]
}

function copy(obj){
​    var o={}
​    for (var prop in obj){
​        if(obj.hasOwnProperty){
​            if(typeof(obj[prop])==='object'){
​                o[prop]=obj[prop].constructor===Array?[]:{};
​                o[prop]=copy(obj[prop])
​            }else{
​                o[prop]=obj[prop]
​            }
​        }
​    }
​    return o;
}
obj2=copy(obj1);

obj2.id=2;
obj2.arr[0]=0

obj1.id//1
obj2.id//2

obj1.arr//[1,2]
obj2.arr//[0,2]
```

**### JSON.parse(JSON.stringify(XXXX))实现对象的深拷贝(多层对象)**

JSON对象parse方法可以将JSON字符串反序列化成JS对象，stringify方法可以将JS对象序列化成JSON字符串，借助这两个方法，也可以实现对象的深拷贝。

参考[javaScript中浅拷贝和深拷贝的实现](https://github.com/wengjq/Blog/issues/3)

```java
var obj1={
​    id:1,
​    arr:[1,2]
}
function copy(obj){
​    var o={}
​    o=JSON.parse(JSON.stringify(obj))
​    return o;
}
obj2=copy(obj1);
```

**### es6扩展运算符(...)实现对象的深拷贝(一层对象)**

```java
var obj1={
​    id:1,
​    name:'zhang'
}
obj2={...obj1};
```

**### ES6的Object.assign(一层对象)**

```java
var obj1={
​    id:1,
​    arr:[1,2]
}

function copy(obj){
​    var o={}
​    o=Object.assign({},obj);
​    return o;
}

obj2=copy(obj1);
```

```java
**### slice方法深拷贝数组**
因为slice不是在原数组上修改，而是会返回新的数组。
var arr1=[1,2,3,4,5];
var arr2=arr1.slice(0);
arr2.push(6);
console.log(arr1);//[1, 2, 3, 4, 5]
console.log(arr2);//[1, 2, 3, 4, 5, 6]

**### concat方法，因为concat不是在原数组上修改，而是会返回新的数组**
var arr1=[1,2,3,4,5];
var arr2=arr1.concat();
arr2.push(6);
console.log(arr1);//[1, 2, 3, 4, 5]
console.log(arr2);//[1, 2, 3, 4, 5, 6]


**### es6提供的方法 Array.from()**
var arr1=[1,2,3,4,5];
var arr2=Array.from(arr1);
arr2.push(6);
console.log(arr1);//[1, 2, 3, 4, 5]
console.log(arr2);//[1, 2, 3, 4, 5, 6]
```

# 二、css

## 2.1 flex弹性布局

flex存在两根轴，水平的主轴和垂直的交叉轴，主轴开始的位置是main start，结束的位置是main end；交叉轴开始的位置是cross start，交叉轴结束的位置是cross end。***默认延主轴排列***

采用flex布局的元素称为flex容器

```css
.box{
	display:flex;
}
```

容器的属性：

### 2.1.1 flex-direction

flex-direction决定主轴的方向。

```scss
.box{
	display:flex;
	flex-direction:row/row-reverse/column/column-reverse
}
```

* row：默认值，代表的是主轴沿水平方向，起点在左端；
* row-reverse：代表的是主轴沿水平方向，起点在右端；
* column：代表的是主轴沿垂直方向，起点在上面；
* column-reverse：代表的是主轴沿垂直方向，起点在下面。

### 2.1.2 flex-wrap

flex-wrap含义是如何换行。

flex-wrap可以取3个值：

* nowrap：默认值，不换行；
* wrap：换行，第一行在上面；
* wrap-reverse：换行，第一行在下面。

### 2.1.3 flex-flow

flex-flow属性是flex-direction和flex-wrap的简写形式，或者说是结合形式。默认值为

flex-flow：row,nowrap;

```css
.box{
	display:flex;
	flex-flow:<flex-direction> <flex-wrap>;
}
```

### 2.1.4 justify-content

Justify-content属性定义了元素在主轴的对齐方式。可以取5个值：

* flex-start：默认值，代表的是左对齐；
* center：代表的是居中
* flex-end：代表的是右对齐；
* space-around：代表的是每个元素之间的间隔相同。所以元素之间的间隔距离是元素与边框间隔距离的两倍；
* space-between：代表的是两端对齐，元素之间的间隔相等。最边上的两个元素是贴着边框的。

```css
.box{
	display:flex;
	justify-content:flex-start/flex-end/center/space-around/space-between
}
```

### 2.1.5 align-items

align-items可以取5个值：

* Flex-start

# 三、React

## 3.1 React diff算法

什么是虚拟dom？

Virtual DOM指的是用JS模拟的DOM结构，将dom的变化放在js层来做，Virtual DOM就是js对象。

为什么要vdom呢？

没有vdom的话我们每次操作dom结点时，不管数据是不是和原来一样，都会重新渲染，我们只希望改动数据变化的dom结点，dom重绘相当消耗浏览器的性能。因此我们采用虚拟dom的方式，将dom对比放在js层，减少不必要的重绘，提高效率。

react并没有说过比原生操作dom快，如果没有vdom，就是重置innerHTMNL。当一个大的列表所有的数据都变化的话，这样重置是比较合理的，但是假如之后一行数据变化了，重置整个innerHTML时，就是多了很多消耗资源的操作。

我们可以对比一下不用vdom的innerHTML和Vdom的重绘的性能消耗：

innerHTML：render html string O(template size) + 重新创建所有的DOM元素O(DOM size)

Vdom：render Virtual DOM + diff O(template size) + 必要的DOM更新**O(DOM change)**

render Virtual DOM + diff O显然比渲染html字符串要慢，但是这依然是js层面的计算，比起后面的dom操作来说依然是便宜了好多，可以看到innerHTML的总计算量不管是js计算还是DOM操作都是和整个界面相关的大小相关的，到那会死Vdom的计算里，只有js计算和界面大小相关，dom的操作设计和数据变化量相关的。

** 为什么要了解diff这块内容呢？**

[什么是diff算法呢？](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.4.6927&rep=rep1&type=pdf)diff算法其实是1986年Myers提出的，用来解决最长公共序列问题(longest common sequence problem，LCS问题)。Dreact核心的两个内容就是virtual dom和diff算法。React diff作为Virtual DOM的加速器，其算法的改进优化是React界面渲染的基础，以及性能提高的保障。虽然开发中不需要知道其运行机制，但是理解之后有助于更好的理解React组件的生命周期，以及优化React程序。

**## react diff和diff有什么不同呢？**

react diff是在diff算法上做了进一步人的优化，[传统的diff算法的时间复杂度是O(n^3)](https://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf),而react diff算法的时间复杂度是O(n)，那么react diff究竟是怎么做到的呢？

其实，react diff是在传统的diff算法上做了三个假设条件:

\>1⃣️DOM 节点跨层级的移动操作特别少，可以忽略不计。

\>2⃣️拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。

\>3⃣️对于同一层级的一组子节点，它们可以通过唯一 id(key) 进行区分。

基于以上三个前提策略，React 分别对 ***\*tree diff、component diff 以及 element diff\**** 进行算法优化。

**### tree diff**

基于假设一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。React对树做了层级控制，只会对某个节点的所有子节点进行比较，如下图，只会对同一颜色方框内的节点进行比较，而不会跨层级进行比较，传统的diff算法是跨层级对每个节点进行两两比较。如果一个父节点不存在了，那么该节点的子节点就不会再进一步比较了。只需要对树遍历一次就可以实现与DOM树的比较。

<!-- ![](/img/tree_diff1.png) -->

<img src="/img/tree_diff1.png" width="500" hegiht="313" align=center />



那如果有跨层级操作的dom节点怎么办呢？如下图A节点跨层级放到D节点的左子节点。React diff用趋近于‘暴力’的方式，并不是把A B C 直接拼接到 D 节点上，而是删除A B C 三个节点之后在 D 下面在创建的 A B C。此时，React diff 的执行情况：create A -> create B -> create C -> delete A。

<!-- ![](/img/tree_diff2.png) -->

<img src="/img/tree_diff2.png" width="500" hegiht="313" align=center />



**### component diff** 

\- 对于同一类型的组件，根据Virtual DOM是否变化也分两种，可以用shouldComponentUpdate()判断Virtual DOM是否发生了变化，若没有变化就不需要在进行diff，这样可以节省大量时间，若变化了，就对相关节点进行update

\- 对于非同一类的组件，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。



如下图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。

<img src="/img/component_diff.png" width="500" hegiht="313" align=center />

**### element diff**

这种情况是我们在开发中最常遇到的，所以详细分析一下这种情况。当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。

我们先来看没经过优化的diff算法在面对这种情况的时候是怎么操作的。

![](/img/element_diff1.png)

如上图，老集合中的节点是A、B、C、D，老集合中的节点是B、A、D、C，当传统的diff算法对新旧集合进行差异化对比时，当拿出新集合中的第一个节点B时，与旧集合中的第一个节点进行比较，发现B != A,此时，旧集合会先删除A节点，并创建B节点，后续会删除B、C、D节点创建A、D、C，这样下来我们发现会频繁的创建和删除dom节点，极大地降低页面的性能。这个时候我们想能不能通过移动现有的节点生成新的集合，而不是频繁的创建和删除节点呢？

<img src="/img/element_diff2.png" width="500" hegiht="313" align=center />

那么react diff 算法是怎么做的呢？优化后的react算法通过给每一个组件加一个key值，也就是给每一个组件加一个唯一性的标识。如下图，当react diff算法对新旧集合进行差异化对比时，发现新集合中的节点B在老集合中能找到，便对老集合中的B不做任何操作。

<!-- ![](/img/element_diff3.png =200x300) -->

<img src="/img/element_diff3.png" width="500" hegiht="313" align=center />

## 3.2为什么要key？

官网上给的一句话是key帮助React准确识别哪些元素改变了，比如添加或者删除。

###为什么不用index当作key？

在列表渲染过程中，react通常会让加key，不加key时会有warning，最初为了消除warning，通常会把key设置为index，但是假如在这样的状况：我们改变列表的顺序或者是在表头增加列表项的时候，会导致重新创建列表项，特别是在表头新增列表项的时候会导致列表创建后面所有的项。因此更好的办法是使用列表项的id作为key值，这样既能保证key值的唯一性又能减少资源浪费。

新增一个

```javascript
               Before                          After  
key=0 {checked:true,msg:'dinner'}  => {checked:false,msg:'TV'} 
key=1 {checked:false,msg:'jogging'}=> {checked:true,msg:'dinner'}
key=2 {checked:false, msg:'sleep'} => {checked:false,msg:'jogging'}
key=3                              => {checked:false,msg:'sleep'}
```

key设置为id

```java
                  Before                          After  
key=id0                              =>{checked:false,msg:'TV'} 
key=id1 {checked:true,msg:'dinner'}  =>{checked:true,msg:'dinner'}
key=id2 {checked:false,msg:'jogging'}=>{checked:true,msg:'jogging'}
key=id3 {checked:false, msg:'sleep'} =>{checked:false,msg:'sleep'}
```

参考：https://medium.com/@as790726/%E7%82%BA%E4%BB%80%E9%BA%BC%E4%B8%8D%E8%A6%81%E7%B8%BD%E6%98%AF%E7%9B%B4%E6%8E%A5%E7%94%A8-array-%E7%9A%84-index-%E7%95%B6-react-component-%E7%9A%84-key-f8290f56b97c

**setState的机制是什么？**

https://juejin.im/post/5bf1444cf265da614a3a1660

setState是异步的，即执行完之后没有办法获取最新的state值，需要经过React对state的所有改变进行合并处理之后，才能计算出新的虚拟dom，再根据最新的dom去重新渲染真实的dom。

```javascript
class App extends Component{
  state={
    count:0
  }
  componentDidMount(){
    this.setState({count:this.state.count+1});
    console.log(this.state.count)
  }
  render(){
    ...
  }
}
```

那么怎么才能获取最新的修改后的state的值呢？可以通过回调函数去实现

```javascript
		...
    this.setState({count:this.state.count+1},()=>{
      console.log(this.state.count)//1
    })
		...
```

如果我们这样去做，

```java
	...
	this.setState({count:this.state.count+1})
	this.setState({count:this.state.count+1})
	...
```

最终输出的是1，因为在第一句执行完之后count还是0。

那么怎么才能实现结果是2呢？prevState可以拿到改变后的值

```
this.setState(prevState=>{count:prevState.count+1});
this.setState(prevState=>{count:prevState.count+1});
```

setState接受的是一个函数作为参数，函数的参数就是上一次的state。

```javascript
this.setState({count:this.state.count+1});
console.log("console",this.state.count);
this.setState({count:this.state.count+1},()={
	console.log("callback",this.state.count)
})
this.setState(prevState=>{  
	console.log("function",this.state.count)
	return{
	count:this.state.count+1;
	}
},()=>{
	console.log("last console",this.state.count)
})
```

输出顺序是：

```javascript
console 0
function 1
callback 2
last console 2
```

react会维护一个state的更新队列，每次调用setState时都会把修改推到这个队列，在最后进行合并处理，然后去执行回调。根据最终合并的结果再去更新虚拟dom，触发渲染。

**合成事件**

为了解决跨平台的问题，react自己封装了一套事件机制，代理了原生的事件，像在jsx中常见的onClick和onChang都是合成事件。

```javascript
class App extends Component {
  state = {
    count: 0
  };

  componentDidMount() {
    // 生命周期中调用
    this.setState({ count: this.state.count + 1 });
    console.log("lifecycle: " + this.state.count);//0
    setTimeout(() => {
      // setTimeout中调用
      this.setState({ count: this.state.count + 1 });
      console.log("setTimeout: " + this.state.count);
    }, 0);//2
    document.getElementById("div2").addEventListener("click", this.increment2);
  }

  increment = () => {
    // 合成事件中调用
    this.setState({ count: this.state.count + 1 });
    console.log("react event: " + this.state.count);
  };

  increment2 = () => {
    // 原生事件中调用
    this.setState({ count: this.state.count + 1 });
    console.log("dom event: " + this.state.count);
  };

  render() {
    return (
      <div className="App">
        <h2>couont: {this.state.count}</h2>
        <div id="div1" onClick={this.increment}>
          click me and count+1
        </div>
        <div id="div2">click me and count+1</div>
      </div>
    );
  }
}
```

上面的4种输出方式，合成的事件是increment，原生的是increment2，合成的事件setState之后不会马上改变count的值，原生的方法会马上改变count的值。

其中的原因是setState并不是真正意义上的异步，而只是模拟了异步的操作，React中会维护一个标志，isBatchingUpdates，判断是直接更新还是暂存在state队列中，setTimeout方法会直接去更新state中的count的值，合成事件是react的生命周期函数，所以会收到react的约束，isBatchingUpdates设置为true，从而走类似异步那套。

总结：

**1、setState在合成事件中是异步的，但是在原生的事件中setState是同步的。**

2、最新的state中的count的值是可以通过setState中的回调函数拿到的。setState的异步并不是内部代码实现的，代码执行的是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在钩子函数和合成时间中是没有办法立马拿到state中的值的。

3、setState的批量更新也是建立在异步之上的，在原生事件和setTimeout中是不会批量更新的，在异步更新中的如果对一个值进行多次的setState，setState的批量更新策略会对其覆盖，最后一次的更新会覆盖前面的更新。

## 3.3 Hooks

React Hooks是react v16.8版本引入的全新的API，RN是在0.59版本引用的。

React Hooks的设计目的，就是加强版函数组件，完全不使用类，就能写出一个全功能的组件。

react hooks的意思是，组件尽量写成纯函数，需要外部功能和副作用，就用钩子把外部代码钩进来。

https://github.com/brickspert/blog/issues/26

https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d#heading-30

Q：为什么只能在函数最外层调用 Hook？为什么不要在循环、条件判断或者子函数中调用。

A：memoizedState 数组是按 hook定义的顺序来放置数据的，如果 hook 顺序变化，memoizedState 并不会感知到。

Q：自定义的 Hook 是如何影响使用它的函数组件的？

A：共享同一个 memoizedState，共享同一个顺序。

Q：“Capture Value” 特性是如何产生的？

A：每一次 ReRender 的时候，都是重新去执行函数组件了，对于之前已经执行过的函数组件，并不会做任何操作。

四个常用的钩子：**useState();useContext();useReducer();useEffect()**

**useState**

useState用于为函数组件引入状态。

```javascript
export default function button(){
	const [buttonText,setButtonText] = useState("click me");
  function handClick(){
    return setButtonText("been clicked!")
  }
  return <button onclick={handClick}>{buttonText}</button>
}
```

useState返回值是数组，数组的第一个值是当前状态的当前值，第二个值是更新状态的方法。

**useContext**

组件之间共享状态可以使用这个函数，比如现在有两个组件

```javascript
<div className="app">
	<Navbar/>
	<Message/>
</div>	
```

可以先使用React Context API，在组件外部建立一个Context。

```javascript
const AppContext = React.createContext({})
```

组件封装如下

```java
<AppContext.Provider value={{
	username:'superawesome'
}}>
	<div className='App'>
    <Navbar/>
    <Message/>
	</div>
</AppContext.Provider>	
```

Navbar组件：

```javascript
const Navbar = ()=>{
	const {username} = useContext(AppContext);
	return (
		<div className='navbar'>
			<p>{username}</p>
		</div>
	)
}
```

同样组件Message中也可以获取username

```html
const Message = ()=>{
	{username} = userContext(AppContext);
	return(
		<div classname='message'>
			<p>{username}</p>
		</div>
	)
}
```

## useReducer()：action 钩子

React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。

Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是`(state, action) => newState`。

`useReducers()`钩子用来引入 Reducer 功能。

> ```javascript
> const [state, dispatch] = useReducer(reducer, initialState);
> ```

上面是`useReducer()`的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的`dispatch`函数。

下面是一个计数器的例子。用于计算状态的 Reducer 函数如下。

> ```javascript
> const myReducer = (state, action) => {
> switch(action.type)  {
>  case('countUp'):
>    return  {
>      ...state,
>      count: state.count + 1
>    }
>  default:
>    return  state;
> }
> }
> ```

组件代码如下。

> ```javascript
> function App() {
> const [state, dispatch] = useReducer(myReducer, { count:   0 });
> return  (
>  <div className="App">
>    <button onClick={() => dispatch({ type: 'countUp' })}>
>      +1
>    </button>
>    <p>Count: {state.count}</p>
>  </div>
> );
> }
> ```

## useEffect()：副作用钩子

`useEffect()`用来引入具有副作用的操作，最常见的就是向服务器请求数据。以前，放在`componentDidMount`里面的代码，现在可以放在`useEffect()`。

1. 有两个参数 callback 和 dependencies 数组
2. 如果 dependencies 不存在，那么 callback 每次 render 都会执行
3. 如果 dependencies 存在，只有当它发生了变化， callback 才会执行

`useEffect()`的用法如下。

> ```javascript
> useEffect(()  =>  {
> // Async Action
> }, [dependencies])
> ```

上面用法中，`useEffect()`接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，`useEffect()`就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行`useEffect()`。

下面看一个例子。

> ```javascript
> const Person = ({ personId }) => {
> const [loading, setLoading] = useState(true);
> const [person, setPerson] = useState({});
> 
> useEffect(() => {
>  setLoading(true); 
>  fetch(`https://swapi.co/api/people/${personId}/`)
>    .then(response => response.json())
>    .then(data => {
>      setPerson(data);
>      setLoading(false);
>    });
> }, [personId])
> 
> if (loading === true) {
>  return <p>Loading ...</p>
> }
> 
> return <div>
>  <p>You're viewing: {person.name}</p>
>  <p>Height: {person.height}</p>
>  <p>Mass: {person.mass}</p>
> </div>
> }
> ```

上面代码中，每当组件参数`personId`发生变化，`useEffect()`就会执行。组件第一次渲染时，`useEffect()`也会执行。****

## 创建自己的 Hooks

上例的 Hooks 代码还可以封装起来，变成一个自定义的 Hook，便于共享。

> ```javascript
> const usePerson = (personId) => {
> const [loading, setLoading] = useState(true);
> const [person, setPerson] = useState({});
> useEffect(() => {
>  setLoading(true);
>  fetch(`https://swapi.co/api/people/${personId}/`)
>    .then(response => response.json())
>    .then(data => {
>      setPerson(data);
>      setLoading(false);
>    });
> }, [personId]);  
> return [loading, person];
> };
> ```

上面代码中，`usePerson()`就是一个自定义的 Hook。

Person 组件就改用这个新的钩子，引入封装的逻辑。

> ```javascript
> const Person = ({ personId }) => {
> const [loading, person] = usePerson(personId);
> 
> if (loading === true) {
>  return <p>Loading ...</p>;
> }
> 
> return (
>  <div>
>    <p>You're viewing: {person.name}</p>
>    <p>Height: {person.height}</p>
>    <p>Mass: {person.mass}</p>
>  </div>
> );
> };
> ```

# 三、vue

相同点
1 都支持服务器端渲染
2 都有Virtual DOM（虚拟dom）,组件化开发,都有’props’的概念，这是properties的简写。props在组件中是一个特殊的属性，允许父组件往子组件传送数据,都实现webComponent规范
3 数据驱动视图
4 都有支持native的方案,React的React native,Vue的weex
5 构建工具
React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。React可以使用Create React App (CRA)，而Vue对应的则是vue-cli。两个工具都能让你得到一个根据最佳实践设置的项目模板。都有管理状态，React有redux,Vue有自己的Vuex（自适应vue，量身定做）

区别
设计思想
react
1 函数式思想，all in js ,jsx语法，js操控css
2 单项数据流
3 setState重新渲染
4 每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进行控制，如果为true继续渲染、false不渲染，但Vue将此视为默认的优化。

vue
1 响应式思想，也就是基于数据可变的。把html、js、css、组合到一起，也可以通过标签引擎组合到一个页面中
2 双向绑定，每一个属性都需要建立watch监听（页面不用，涉及到组件更新的话需要）
3 Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树

性能
react ----大型项目
优化需要手动去做，状态可控
vue ------中小型项目
状态改变需要watch监听，数据量太大的话会卡顿

扩展性
react
1 类式写法api少，更容易结合ts
2 可以通过高阶组件来扩展
vue
1 声明式写法，结合ts比较复杂
2 需要通过mixin方式来扩展

React刚开始也有mixin的写法，通过React.createClass的api，不过现在很少用了。
Vue也不是不能实现高阶组件，只是特别麻烦，因为Vue对与组件的option做了各种处理，想实现高阶组件就要知道每一个option是怎么处理的，然后正确的设置。具体有多复杂，可以参考下面的文章。
http://hcysun.me/2018/01/05/探索Vue高阶组件





